<!DOCTYPE html><html><head><meta charset="utf-8"><title>笑松小站 | 写我喜欢 读我所爱</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="undefined"><meta name="description" content="个人博客,陶小松,笑松,笑松小站,笑松的小站,笑松博客,笑松的博客"><meta property="og:type" content="website"><meta property="og:title" content="笑松小站"><meta property="og:url" content="http://blog.seoui.com/page/3/index.html"><meta property="og:site_name" content="笑松小站"><meta property="og:description" content="个人博客,陶小松,笑松,笑松小站,笑松的小站,笑松博客,笑松的博客"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="笑松小站"><meta name="twitter:description" content="个人博客,陶小松,笑松,笑松小站,笑松的小站,笑松博客,笑松的博客"><link rel="alternative" href="/atom.xml" title="笑松小站" type="application/atom+xml"><link rel="alternative" href="/sitemap.xml" title="笑松小站" type="application/atom+xml"><meta name="summary" content="个人博客,陶小松,笑松,笑松小站,笑松的小站,笑松博客,笑松的博客"><meta http-equiv="Pragma" content="no-cache"><meta http-equiv="Cache-Control" content="no-cache"><meta http-equiv="Expires" content="0"><link rel="shortcut icon" href="/assets/images/favicon.ico"><link rel="stylesheet" href="/assets/styles/style.css"></head><body><div id="loading" class="active"></div><nav id="menu"><div class="inner flex-row-vertical"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off"><i class="icon icon-lg icon-close"></i></a><div class="brand-wrap"><div class="brand"> <a href="/" class="avatar"><img src="/assets/images/logo.png"></a><hgroup class="introduce"><h5 class="nickname"></h5><div class="email">写我喜欢 读我所爱</div></hgroup></div></div><ul class="nav flex-col"><li class="waves-block waves-effect"><a href="/"><i class="icon icon-lg icon-home"></i> Home</a></li><li class="waves-block waves-effect"><a href="/archives"><i class="icon icon-lg icon-archives"></i> Archives</a></li><li class="waves-block waves-effect"><a href="/tags"><i class="icon icon-lg icon-tags"></i> Tags</a></li><li class="waves-block waves-effect"><a href="/guestbook"><i class="icon icon-lg icon-book"></i> About</a></li><li class="waves-block waves-effect"><a href="/links"><i class="icon icon-lg icon-links"></i> Links</a></li></ul><footer class="footer"><p> <a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0;vertical-align:middle" src="/assets/images/cc-by-nc-nd.svg"></a></p><p>笑松小站 &copy; 2014~2016.</p><p>All Rights Reserved.</p><p><a href="/atom.xml" target="_blank" class="rss" style="position:inherit" title="rss"><i class="icon icon-2x icon-rss-square"></i></a><a href="/sitemap.xml" target="_blank" class="sitemap" style="color:#E64A19" title="sitemap"><i class="icon icon-2x icon-sitemap"></i></a></p></footer></div></nav><main id="main"><header class="header" id="header"><div class="flex-row"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle"><i class="icon icon-lg icon-navicon"></i></a><div class="flex-col header-title ellipsis">笑松小站</div><div class="search-wrap" id="search-wrap"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back"><i class="icon icon-lg icon-chevron-left"></i></a> <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search"><i class="icon icon-lg icon-search"></i></a></div><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-share"><i class="icon icon-lg icon-share-alt"></i></a></div></header><header class="content-header"><div class="container"><h1 class="author">笑松小站</h1><h5 class="subtitle">写我喜欢 读我所爱</h5></div></header><div class="container body-wrap"><ul class="post-list"><li class="post-list-item"><article id="post-linux.usergroupmanager" class="article article-type-post" itemprop="blogPost"><h3 class="post-title" itemprop="name"> <a class="post-title-link" href="/2015/09/05/linux.usergroupmanager/">Linux用户与用户组管理</a></h3><div class="post-meat flex-row"><div class="flex-col"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul></div> <time datetime="2015-09-04T16:00:00.000Z" itemprop="datePublished" class="post-tiem">2015-09-05</time></div><div class="post-content" id="post-content" itemprop="postContent"> Linux 为系统默认配置了N多的用户 它们都保存在/etc/passwd文件中。如下图 每一个用户由 用户名：密码：用户标识：组标识:描述:所属目录:shell 7个字段组合而成,其中密码是加密的 使用X字符替代。这些用户都是系统内置的 shell字段为/sbin/nologin时 这个用户是不可登陆的。只是为了完成一些独有的功能而存在。 由于密码是加密的那么/etc/shadow文件专门用来保存用户的密码信息。 另外介绍一个用户组文件信息是保存在/etc/group 文件中的。 ##用户管理## useradd 添加用户 [root@localhost ~]# useradd --help Usage: useradd [options] LOGIN Options: -b, --base-dir BASE_DIR base directory for the home directory of the new account -c, --comment COMMENT GECOS field of the new account -d, --home-dir HOME_DIR home directory of the new account -D, --defaults print or change default useradd configuration -e, --expiredate EXPIRE_DATE expiration date of the new account -f, --inactive INACTIVE password inactivity period of the new account -g, --gid GROUP name or ID of the primary group of the new account -G, --groups GROUPS list of supplementary groups of the new account -h, --help display this help message and exit -k, --skel SKEL_DIR use this alternative skeleton directory -K, --key KEY=VALUE override /etc/login.defs defaults -l, --no-log-init do not add the user to the lastlog and faillog databases -m, --create-home create the user's home directory -M, --no-create-home do not create the user's home directory -N, --no-user-group do not create a group with the same name as the user -o, --non-unique allow to create users with duplicate (non-unique) UID -p, --password PASSWORD encrypted password of the new account -r, --system create a system account -s, --shell SHELL login shell of the new account -u, --uid UID user ID of the new account -U, --user-group create a group with the same name as the user -Z, --selinux-user SEUSER use a specific SEUSER for the SELinux user mapping 例如： useradd -c &#39;this a comment&#39; abcabc 添加一个用户abcabc cat /etc/passwd 查看用户信息文件 abcabc:x:503:504:this a comment:/home/abcabc:/bin/bash abcabc添加成功。 为abcabc用户设置密码passwd abcabc 注意 如果passwd命令后不输入用户名 则默认修改当前登陆用户的密码 passwd abcabc 添加用户同时指定一个普通用户组 如系统中已存在用户组shareGroup useradd -c 'this a comment' abcabc -G shareGroup usermod 修改用户 usermod -l abc abcabc 修改用户名abcabc为abc usermod -G share2 添加一个用户组share2 usermod -L abc 锁定abc用户 usermod -U abc 为abc用户解除锁定状态 userdel 删除用户 userdel abc 删除用户abc 不会删除用户的所属文件目录 userdel -r abc 删除用户abc 同时会删除用户所属的文件目录 ##用户组管理## groupadd 添加组 groupadd ugroup1 添加用户组ugroup1 groupmod 修改用户组 groupdel 删除组 groupdel ugroup1 删除用户组ugroup1 用户组与用户管理的操作差不多是一样的。不在一一说明。</div><div class="post-footer clearfix"> <a href="/2015/09/05/linux.usergroupmanager/" class="post-more waves-effect waves-button waves-light">阅读更多</a></div></article></li><li class="post-list-item"><article id="post-linux.switchUser" class="article article-type-post" itemprop="blogPost"><h3 class="post-title" itemprop="name"> <a class="post-title-link" href="/2015/09/05/linux.switchUser/">Linux用户切换</a></h3><div class="post-meat flex-row"><div class="flex-col"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul></div> <time datetime="2015-09-04T16:00:00.000Z" itemprop="datePublished" class="post-tiem">2015-09-05</time></div><div class="post-content" id="post-content" itemprop="postContent"> 有时候用一个普通权限的用户登录系统 而需要管理员的权限的时候可以使用 su 或者 sudo 命令完成。 如 在abc用户下 切换到root用户 从而实现一些root权限的操作 [abc@localhost ~]$ su root Password: [root@localhost abcabc]# 还有一种需求是 我不希望切换到root用户环境下,但是我想暂时拥有root权限 可以使用 sudo 如下在abc用户下想查看/etc/shadow这个文件内容 而这个文件是权限只是对root可读，使用以下命令 输入密码后可顺利执行。 [abc@localhost ~]$ sudo cat /etc/shadow</div><div class="post-footer clearfix"> <a href="/2015/09/05/linux.switchUser/" class="post-more waves-effect waves-button waves-light">阅读更多</a></div></article></li><li class="post-list-item"><article id="post-linux.find" class="article article-type-post" itemprop="blogPost"><h3 class="post-title" itemprop="name"> <a class="post-title-link" href="/2015/09/05/linux.find/">Linux查找</a></h3><div class="post-meat flex-row"><div class="flex-col"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul></div> <time datetime="2015-09-04T16:00:00.000Z" itemprop="datePublished" class="post-tiem">2015-09-05</time></div><div class="post-content" id="post-content" itemprop="postContent"></div><div class="post-footer clearfix"> <a href="/2015/09/05/linux.find/" class="post-more waves-effect waves-button waves-light">阅读更多</a></div></article></li><li class="post-list-item"><article id="post-eventBubbling" class="article article-type-post" itemprop="blogPost"><h3 class="post-title" itemprop="name"> <a class="post-title-link" href="/2015/09/01/eventBubbling/">javascript事件冒泡问题</a></h3><div class="post-meat flex-row"><div class="flex-col"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul></div> <time datetime="2015-08-31T16:00:00.000Z" itemprop="datePublished" class="post-tiem">2015-09-01</time></div><div class="post-content" id="post-content" itemprop="postContent"> 一个如上图的DOM结构 首先是table-&gt;tr-&gt;td-&gt;div-&gt;span，分别使用jQuery的api对td div span 分别绑定了click事件。代码如下 $( "#join td" ).click( function ( ) &#123; alert( "这是td" ); &#125;); $( "#join div" ).click( function ( ) &#123; alert( "这是div" ); &#125;); $( "#join .abc" ).click( function ( ) &#123; alert( "这是span" ); &#125;); 当点击td的时候弹出”这是TD”、点击div的时候弹出”这是DIV”,”这是TD”、点击span的时候弹出 “这是span”,”这是DIV”,”这是TD” 这种现象被称为事件的传播，也叫事件冒泡 事件冒泡通常在使用中不合理的。那么怎么解决呢? 在W3c中，使用stopPropagation、preventDefault方法可以可以制止事件的默认行为。 $( "#nojoin td" ).click( function ( event ) &#123; alert( "这是td 2" ); event.preventDefault(); event.stopPropagation(); &#125;); $( "#nojoin div" ).click( function ( event ) &#123; alert( "这是div 2 " ); event.preventDefault(); event.stopPropagation(); &#125;); $( "#nojoin .abc" ).click( function ( event ) &#123; alert( "这是span 2" ); event.preventDefault(); event.stopPropagation(); &#125;); 嘿 这次实验成功了。得到了我们期望的效果。 使用jQuery事件回调return false 也可以实现相同的效果。从而少些一些代码，何乐而不为呢。 $( "#nojoin td" ).click( function ( event ) &#123; alert( "这是td 2" ); return false ; &#125;); $( "#nojoin div" ).click( function ( event ) &#123; alert( "这是div 2 " ); return false ; &#125;); $( "#nojoin .abc" ).click( function ( event ) &#123; alert( "这是span 2" ); return false ; &#125;); 其实jQuery的事件回调中可以通过return false来阻止事件传播。翻阅jQuery源码 只要return false 其实它也是执行了 preventDefault,stopPropagation 这2个方法。 附上jQuery源码 if ( ret !== undefined ) &#123; if ( (event.result = ret) === false ) &#123; event.preventDefault(); event.stopPropagation(); &#125; &#125; 本示例演示地址: https://cqweclick.github.io/eventBubbling.html</div><div class="post-footer clearfix"> <a href="/2015/09/01/eventBubbling/" class="post-more waves-effect waves-button waves-light">阅读更多</a></div></article></li><li class="post-list-item"><article id="post-linux.file.authority" class="article article-type-post" itemprop="blogPost"><h3 class="post-title" itemprop="name"> <a class="post-title-link" href="/2015/08/30/linux.file.authority/">Linux文件权限配置</a></h3><div class="post-meat flex-row"><div class="flex-col"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul></div> <time datetime="2015-08-29T16:00:00.000Z" itemprop="datePublished" class="post-tiem">2015-08-30</time></div><div class="post-content" id="post-content" itemprop="postContent"> 简单的使用 ls -l 一下就可以看到当前目录的文件列表 其中列表中包含了文件的权限信息、宿主用户、所属用户组、文件大小、时间 等一些列信息。 权限字符串 文件的权限字符一共是10位，第1为是文件类型。后面分别为3组权限如下所示。 r表示可读 、w表示可写、x表示可执行(可以理解为可以看到)、 - 表示没有权限使用 - 站位。 文件类型 宿主权限 用户组权限 其他用户权限 d - rwx rwx rwx 字符串授权 宿主权限 用户组权限 其他用户权限 u+操作（r/w/x） g+操作（r/w/x） o+操作（r/w/x） 在管理员权限下使用命令 chmod 进行授权 如 文件text.txt授权用户组 写读、可写、写执行权限 chmod g+rwx text.txt 如 文件text.txt删除用户组 写读、可写、写执行权限 chmod g-rwx text.txt 如 文件text.txt授权其他用户 写读、可写权限 chmod o+rw text.txt 如 文件text.txt授权宿主用户 写读 权限 chmod u+r text.txt 看起来比较简单，但是授权的过程比较繁琐 不方便。不支持对宿主 用户组 其他用户同时授权，那么接下来将使用 数字 的方式授权就相对于方便很多了。 数字授权 同样和字符串授权一样也是分为3组权限 如下。只是权限操作使用数字来替代 变得更加灵活了。 宿主权限 用户组权限 其他用户权限 r=4、 w=2、 x=1 r=4、 w=2、 x=1 r=4、 w=2、 x=1 列举一个例子，以前不懂授权的时候 在网上搜索 为文件授权的命令是 chmod 777 filename 我真的很纳闷777是什么意思呢? 直到今天才明白第一个7代表宿主权限（4+2+1）,第2个7代表用户组权限（4+2+1）,第3个7代表其他用户（4+2+1）。所有这个命令的意思就是授予宿主、用户组、其他用户的权限都有可读、可写、可执行。 列举一个场景 为 宿主用户 授予可读、可写、可执行，为 用户组 授予可读、可写、可执行、为 其他用户 授予可读，不可写，可执行权限 宿主权限：4+2+1 用户权限:4+2+1 其他用户权限:4+1 所以 这个权限数字为775 linux的权限感觉比较繁琐，但还是比较好理解。这里只记录这一点。对日常的操作已经满足了。还有更深入的权限操作没有讲到。</div><div class="post-footer clearfix"> <a href="/2015/08/30/linux.file.authority/" class="post-more waves-effect waves-button waves-light">阅读更多</a></div></article></li><li class="post-list-item"><article id="post-linux.general.command" class="article article-type-post" itemprop="blogPost"><h3 class="post-title" itemprop="name"> <a class="post-title-link" href="/2015/08/29/linux.general.command/">Linux常用命令</a></h3><div class="post-meat flex-row"><div class="flex-col"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul></div> <time datetime="2015-08-28T16:00:00.000Z" itemprop="datePublished" class="post-tiem">2015-08-29</time></div><div class="post-content" id="post-content" itemprop="postContent"> 首先介绍几个方便的操作 通配符 * 匹配任意字符 如 test* ? 匹配任意单个字符 如 te?t [] 匹配任意指定的字符 如myn[123] 匹配 myn1 、myn2 myn3 命令补全 在编写命令的时候 如mkdir命令 输入mk按下Tab键会把mk开头的所有命令显示出来。 当然也可以匹配文件 在使用过程中效率非常高。 命令历史 使用命令 history 可以查看当前用户键入过的所有命令。 使用 !! 命令可以执行上一次执行命令。 也可以使用 ! 跟上命令前缀或命令全名 会在历史记录中查找并执行命令。 常用命令 组合命令 以 ls 为例 ls -al 表示同时显示所有文件 并显示详细信息。 常用命令 ls 浏览 文件目录信息 默认是当前文件也可以使用参数 ls -a /etc/ 一些linux系统还支持 ll 命令 效果如ls命令，但ls是标准的命令所有linux系统都支持。 pwd 当前所在目录的路径 pwd cd 进入到指定的目录 /代表根目录 常用的文件系统操作 在介绍文件操作的命令之前介绍一下Linux的文件类型 d 目录文件。 l 符号链接(指向另一个文件,类似于瘟下的快捷方式)。 s 套接字文件。 b 块设备文件,二进制文件。 c 字符设备文件。 p 命名管道文件。 - 普通文件，或更准确地说，不属于以上几种类型的文件 mkdir 创建目录 mkdir ttt rmdir 删除目录 rmdir ttt file 显示文件的类型 touch 创建或更新文件 cp 复制文件 cp 需要复制的文件 新的文件名称 复制目录需要加上参数-r rm 删除文件 删除目录需要加参数-r -f参数可以不用确认 mv 移动文件 mv 文件 移动文件的目标位置 cat 查看文件内容 不分页 more 查看文件内容 分页 less 查看文件内容 分页 和more一样 head 查看文件指定前几行内容 如head -10 /etc/passwd 显示前10行内容 tail 查看文件指定后几行内容 如tail -10 /etc/passwd 显示后10行内容 方便的重定向功能 重定向分为 输入重定向、输出重定向、错误重定向。 如 cat test.txt&gt; testlog.txt 会把cat的结果重定向到testlog.txt文件中。会追加数据 cat test.txt &gt;&gt; testlog.txt 会把cat的结构重定向到testlog.txt文件中，会覆盖以前的数据。 管道操作 什么是管道? 我认为管道就是为一些结果做过滤操作的，比较实用。 | 表示管道连接符 如 ls -l | more 会分页显示ls的结果 ls -l |grep fff 会过滤出ls中包含fff的结果</div><div class="post-footer clearfix"> <a href="/2015/08/29/linux.general.command/" class="post-more waves-effect waves-button waves-light">阅读更多</a></div></article></li><li class="post-list-item"><article id="post-httpinfolist" class="article article-type-post" itemprop="blogPost"><h3 class="post-title" itemprop="name"> <a class="post-title-link" href="/2015/08/19/httpinfolist/">HTTP Header详细文档</a></h3><div class="post-meat flex-row"><div class="flex-col"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/">HTTP</a></li></ul></div> <time datetime="2015-08-18T16:00:00.000Z" itemprop="datePublished" class="post-tiem">2015-08-19</time></div><div class="post-content" id="post-content" itemprop="postContent"> HTTP（HyperTextTransferProtocol）即超文本传输协议，目前网页传输的的通用协议。HTTP协议采用了请求/响应模型，浏览器或其他客户端发出请求，服务器给与响应。就整个网络资源传输而言，包括message-header和message-body两部分。首先传递message- header，即http header消息 。http header 消息通常被分为4个部分：general header, request header, response header, entity header。但是这种分法就理解而言，感觉界限不太明确。根据维基百科对http header内容的组织形式，大体分为Request和Response两部分。 Requests部分 Header 含义 例子 Accept 指定客户端能够接收的内容类型 Accept: text/plain, text/html Accept-Charset 浏览器可以接受的字符编码集。 Accept-Charset: iso-8859-5 Accept-Encoding 指定浏览器可以支持的web服务器返回内容压缩编码类型。 Accept-Encoding: compress, gzip Accept-Language 浏览器可接受的语言 Accept-Language: en,zh Accept-Ranges 可以请求网页实体的一个或者多个子范围字段 Accept-Ranges: bytes Authorization HTTP授权的授权证书 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Cache-Control 指定请求和响应遵循的缓存机制 Cache-Control: no-cache Connection 表示是否需要持久连接。（HTTP 1.1默认进行持久连接） Connection: close Cookie |HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。| Cookie: $Version=1; Skin=new;| |Content-Length |请求的内容长度| Content-Length: 348| |Content-Type |请求的与实体对应的MIME信息 |Content-Type: application/x-www-form-urlencoded| |Date |请求发送的日期和时间 |Date: Tue, 15 Nov 2010 08:12:31 GMT| |Expect |请求的特定的服务器行为| Expect: 100-continue| |From |发出请求的用户的Email| From: user@email.com| |Host |指定请求的服务器的域名和端口号 |Host: www.zcmhi.com| |If-Match |只有请求内容与实体相匹配才有效| If-Match: “737060cd8c284d8af7ad3082f209582d”| |If-Modified-Since |如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码| If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT| |If-None-Match |如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变 |If-None-Match: “737060cd8c284d8af7ad3082f209582d”| |If-Range | 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag| If-Range: “737060cd8c284d8af7ad3082f209582d”| |If-Unmodified-Since | 只在实体在指定时间之后未被修改才请求成功 |If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT| |Max-Forwards |限制信息通过代理和网关传送的时间| Max-Forwards: 10| |Pragma |用来包含实现特定的指令| Pragma: no-cache| |Proxy-Authorization | 连接到代理的授权证书| Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==| |Range |只请求实体的一部分，指定范围| Range: bytes=500-999| |Referer |先前网页的地址，当前请求网页紧随其后,即来路 |Referer: http://blog.peachyy.com| |TE |客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息| TE: trailers,deflate;q=0.5| |Upgrade |向服务器指定某种传输协议以便服务器进行转换（如果支持）| Upgrade: HTTP/2.0, |SHTTP/1.3, IRC/6.9, RTA/x11| |User-Agent | User-Agent 的内容包含发出请求的用户信息 |User-Agent: Mozilla/5.0 (Linux; X11)| |Via | 通知中间网关或代理服务器地址，通信协议| Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)| |Warning |关于消息实体的警告信息 |Warn: 199 Miscellaneous warning| Responses Header 含义 例子 Accept-Ranges 表明服务器是否支持指定范围请求及哪种类型的分段请求 Accept-Ranges: bytes Age 从原始服务器到代理缓存形成的估算时间（以秒计，非负） Age: 12 Allow 对某网络资源的有效的请求行为，不允许则返回405 Allow: GET, HEAD Cache-Control 告诉所有的缓存机制是否可以缓存及哪种类型 Cache-Control: no-cache Content-Encoding web服务器支持的返回内容压缩编码类型。 Content-Encoding: gzip Content-Language 响应体的语言 Content-Language: en,zh Content-Length 响应体的长度 Content-Length: 348 Content-Location 请求资源可替代的备用的另一地址 Content-Location: /index.htm Content-MD5 返回资源的MD5校验值 Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ== Content-Range 在整个返回体中本部分的字节位置 Content-Range: bytes 21010-47021/47022 Content-Type 返回内容的MIME类型 Content-Type: text/html; charset=utf-8 Date 原始服务器消息发出的时间 Date: Tue, 15 Nov 2010 08:12:31 GMT ETag 请求变量的实体标签的当前值 ETag: “737060cd8c284d8af7ad3082f209582d” Expires 响应过期的日期和时间 Expires: Thu, 01 Dec 2010 16:00:00 GMT Last-Modified 请求资源的最后修改时间 Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT Location 用来重定向接收方到非请求URL的位置来完成请求或标识新的资源 Location: http://www.zcmhi.com/archives/94.html Pragma 包括实现特定的指令，它可应用到响应链上的任何接收方 Pragma: no-cache Proxy-Authenticate 它指出认证方案和可应用到代理的该URL上的参数 Proxy-Authenticate: Basic refresh 应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持） Refresh: 5; url= http://blog.peachyy.com Retry-After 如果实体暂时不可取，通知客户端在指定时间之后再次尝试 Retry-After: 120 Server web服务器软件名称 Server: Apache/1.3.27 (Unix) (Red-Hat/Linux) Set-Cookie 设置Http Cookie Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1 Trailer 指出头域在分块传输编码的尾部存在 Trailer: Max-Forwards Transfer-Encoding 文件传输编码 Transfer-Encoding:chunked Vary 告诉下游代理是使用缓存响应还是从原始服务器请求 Vary: * Via 告知代理客户端响应是通过哪里发送的 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 警告实体可能存在的问题 Warning: 199 Miscellaneous warning WWW-Authenticate 表明客户端请求实体应该使用的授权方案 WWW-Authenticate: Basic @see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html 网络。</div><div class="post-footer clearfix"> <a href="/2015/08/19/httpinfolist/" class="post-more waves-effect waves-button waves-light">阅读更多</a></div></article></li><li class="post-list-item"><article id="post-java8newcharacteristics" class="article article-type-post" itemprop="blogPost"><h3 class="post-title" itemprop="name"> <a class="post-title-link" href="/2015/08/10/java8newcharacteristics/">java8中的一些新特性</a></h3><div class="post-meat flex-row"><div class="flex-col"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java8/">java8</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/新特性/">新特性</a></li></ul></div> <time datetime="2015-08-09T16:00:00.000Z" itemprop="datePublished" class="post-tiem">2015-08-10</time></div><div class="post-content" id="post-content" itemprop="postContent"> 最近看了一下 java8 中的新增特性 新添加的东西个人认为并不多，主要是 lambda 表达式 其他的比较少。 因为之前看过 Groovy 它里面有一种语法叫 闭包/Closure 而java8中的lambda和Groovy中所谓的闭包非常相似，官方也称lambda表达式也可以叫闭包 难道是相互模仿? 不过 ruby 这些语言的写法确实非常优雅 未来的java语法也会像 ruby 一样么 这个是未知的。至少Groovy的出现 证明是可以这么做的。 函数的引用 这里所说的函数 包含普通函数 和构造函数 java8中使用 :: 关键字来传递方法或者构造函数引用 示例如下 这里引用了 Integer.valueOf() 方法 public class FunctionDemo &#123; public static void main (String[] args) &#123; Function&lt;String,Integer&gt; fordate=Integer::valueOf; Integer l=fordate.apply( "25" ); System.out.println(l); &#125; &#125; Lambda 表达式 其实会了Groovy中的闭包以后 java中Lambda表达式基本差不多。 语法 : ()-&gt;{} (int x, int y) -&gt; x + y; (x, y) -&gt; { return x + y; } //显式指明返回值 可见由3部分组成 参数列表，箭头（-&gt;），以及一个表达式或语句块 先给出一个demo 在后面会频繁的使用到Lambda表达式 一个foreach循环 只需要一行代码就搞定。是不是又节约了代码了呢 public class LambdaDemo &#123; public static void main (String[] args) &#123; List&lt;String&gt; list= new ArrayList&lt;&gt;(); list.add( "a1" ); list.add( "a2" ); list.add( "a3" ); list.add( "a4" ); list.add( "a5" ); list.add( "a6" ); list.add( "a7" ); list.forEach(o -&gt; &#123;System.out.println(o);&#125;); //... &#125; &#125; 在接口(interface)中定义默认方法实现 public interface foo &#123; public void sayHell (String hello) ; //默认方法 default double abs ( int a) &#123; return Math.abs(a); &#125; //impl public class fooimpl implements foo &#123; @Override public void sayHell (String hello) &#123; System.out.println( "say:" +hello); &#125; public static void main (String[] args) &#123; foo f= new fooimpl(); f.sayHell( "fff" ); System.out.println(f.abs( 20 )); &#125; &#125; &#125; 函数式接口 首先介绍一个注解 @FunctionalInterface 用来表示这个接口类是不一般的。这是一个函数式接口 如果你违反了函数式接口的规范 那么编译器就会报错,当然这个不是必须的、为了方便阅读代码尽量应该标识。 什么是函数式接口呢? 接口中可以额外定义多个抽象方法、需要注意的是这些抽象方法的修饰签名必须和Object的public一样 举个例子 示例一 是函数式接口 @FunctionalInterface public interface ccc &#123; void sum () ; //来自父类public的toString方法 @Override String toString () ; &#125; 示例二 不是函数式接口 因为clone不是public @FunctionalInterface public interface ccc &#123; void sum () ; //来自父类protected的clone方法 @Override Object clone () ; &#125; 列出java8之前已有的函数接口 java.lang.Runnable java.util.concurrent.Callable java.security.PrivilegedAction java.util.Comparator java.io.FileFilter java.nio.file.PathMatcher java.lang.reflect.InvocationHandler java.beans.PropertyChangeListener java.awt.event.ActionListener javax.swing.event.ChangeListener java8新定义的函数式接口 在rt.jar java.util.function包中 java.util.function.Predicate java.util.function.Consumer java.util.function.Function java.util.function.Supplier java.util.function.UnaryOperator java.util.function.BinaryOperator 那么接下来自定义一个简单的函数接口，你会发现与其他的普通java接口的区别莫过于实现具体的方式变了、变得更加简单 要是jdk1.8之前 会使用到匿名类或者写一个实现类 看到这种写法 以前简直就弱爆了。这就是函数式接口的魅力所在。 @FunctionalInterface //定义一个函数接口ccc public interface ccc &#123; int sum ( int x, int y) ; @Override String toString () ; //这是一个测试类 public class cccTest &#123; public static void main (String[] args) &#123; //一行代码告别匿名类 ccc target=( x, y)-&gt;&#123; int sum=x+y; return sum;&#125;; //调用sum方法 System.out.println(target.sum( 9 , 4 )); &#125; &#125; &#125; Predicate 接口 示例 当传入的参数为null或者长度=0 或者长度&gt;3 那么返回true 否则返回false 接口里面默认提供几个默认方法 default Predicate and(Predicate&lt;? super T&gt; other) 追加and条件 default Predicate negate() 从源码来看 应该是取反值得意思 如test()返回true 那么negate返回false 反之 default Predicate or(Predicate&lt;? super T&gt; other) 追加or条件 示例有用到 public class PredicateDemo &#123; public static void main (String[] args) &#123; Predicate&lt;String&gt; lengthgt3=(s)-&gt;&#123; return s!= null &amp;&amp;s.length()&gt; 3 ;&#125;; lengthgt3=lengthgt3.or((s)-&gt;&#123; return s== null || s.length()== 0 ;&#125;); boolean b= false ; b=lengthgt3.test( null ); System.out.println(b); &#125; &#125; Function 接口 示例 public class FunctionDemo &#123; public static void main (String[] args) &#123; Function&lt;String,Integer&gt; fordate=Integer::valueOf; Integer l=fordate.apply( "25" ); System.out.println(l); &#125; &#125; Supplier 接口 示例 实例化对象 需要注意的是 对象必须要拥有一个无参的构造函数 否则会编译出错。supplier紧紧只有一个get方法 public class SupplierDemo &#123; public static void main (String[] args) &#123; Supplier&lt;User&gt; personSupplier = User:: new ; User u=personSupplier.get(); System.out.println(u.getClass()); &#125; &#125; Consumer 接口 示例 操作单个对象处理 具有一个默认方法 default Consumer andThen(Consumer&lt;? super T&gt; after) public class ConsumerDemo &#123; public static void main (String[] args) &#123; User u1= new User( "xx1" , 20 ); User u2= new User( "xx2" , 21 ); Consumer&lt;User&gt; opt=(u)-&gt;&#123;System.err.println(u.getName()+ "年龄是" +u.getAge());&#125;; opt.accept(u2); &#125; &#125; 操作单个数据 感觉用处并不是很大。 Comparator 接口 示例 比较的时候用得比较多 JDK8中又新增一些方法。以下示例实现了使用compareTo 方法对user对象按照age字段排序 public class ComparatorDemo &#123; public static void main (String[] args) &#123; User u1= new User( "xx1" , 25 ); User u2= new User( "xx2" , 21 ); List&lt;User&gt; uList= new ArrayList&lt;&gt;(); uList.add(u1); uList.add(u2); uList.sort((t ,t1)-&gt;&#123; return t.getAge().compareTo(t1.getAge()); &#125;); for ( int i = 0 ; i &lt; uList.size(); i++) &#123; System.out.println(uList.get(i).getName()+ "~" +uList.get(i).getAge()); &#125; &#125; &#125; 还有一些JDK8自带的 函数式接口 不再一一列举 使用方式都差不多一样的。 Stream序列 Stream 接口拥有很多方法。都是很方便操作数据的。如 Filter 、Sort、count、min、max等等。</div><div class="post-footer clearfix"> <a href="/2015/08/10/java8newcharacteristics/" class="post-more waves-effect waves-button waves-light">阅读更多</a></div></article></li><li class="post-list-item"><article id="post-simplejsPreview1" class="article article-type-post" itemprop="blogPost"><h3 class="post-title" itemprop="name"> <a class="post-title-link" href="/2015/07/22/simplejsPreview1/">js常见面试题</a></h3><div class="post-meat flex-row"><div class="flex-col"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul></div> <time datetime="2015-07-21T16:00:00.000Z" itemprop="datePublished" class="post-tiem">2015-07-22</time></div><div class="post-content" id="post-content" itemprop="postContent"> 列出几道js面试中的题,无意中在什么站点看到的，便记录一下。看完这些题后 你还敢说js很简单么,简直是最优雅 博大精深的语言了。 1、函数声明优先于var var a; function a ( ) &#123; &#125; alert( typeof a); // ? 2、this scope arguments scope var length = 10 function fn ( ) &#123; alert( this .length) &#125; var obj = &#123; length : 5 , method : function ( fn ) &#123; fn() // ?   arguments [ 0 ]() // ?     &#125; &#125; obj.method(fn) 3、函数表达式具名（函数声明同时赋值给另一个变量）或函数声明立即执行时，名仅在该函数内可访问 (不考虑IE 6 7 8) ~ function ( ) &#123;     alert( typeof next) // ?     ~ function next ( ) &#123;         alert( typeof next) // ?     &#125;() &#125;() 4、隐式的全局变量 var a = 1 function func ( ) &#123;     a = b = 2 &#125; func() alert(a) alert(b) // ? 5、变量声明早于代码运行（Scoping and Hoisting） var uname = 'jack' function change ( ) &#123;     alert(uname) // ?      var uname = 'lily'     alert(uname) &#125; change() 还敢说自己JS很NB么 来源于网络、具体在哪记不得了 后来补上出处。由于自己也并非是专业的前端 所以也做错了好几题。</div><div class="post-footer clearfix"> <a href="/2015/07/22/simplejsPreview1/" class="post-more waves-effect waves-button waves-light">阅读更多</a></div></article></li><li class="post-list-item"><article id="post-browerNotification" class="article article-type-post" itemprop="blogPost"><h3 class="post-title" itemprop="name"> <a class="post-title-link" href="/2015/07/21/browerNotification/">浏览器对Notification通知的支持</a></h3><div class="post-meat flex-row"><div class="flex-col"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul></div> <time datetime="2015-07-20T16:00:00.000Z" itemprop="datePublished" class="post-tiem">2015-07-21</time></div><div class="post-content" id="post-content" itemprop="postContent"> 记得在上一次的项目中需要实现一个BS的IM通信小功能、当新信息到达时 会在当前网站的右下角弹出一小弹框来提示用户有新的信息了。当时是在站内弹出一个类似WINDOW这样的窗口来实现的。其实这也可以满足用户的需求、当客户又提出来如果在浏览其他网站的时候、或者浏览器最小化的时候 我怎么知道是否有新消息呢? 当时认为这就是CS对于BS而言的优势所在。当然问题一直都没有得到改善 直到最近在W3C上看到 http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html http://www.w3.org/TR/notifications/ 这篇文章时候、很有自信的说 这种问题已经可以解决了。遗憾的是已经离开了那一家公司。 Notation 被 W3C 提出是浏览器通知的一个标准，最初的草案叫做 webkitNotifications 在网上说 Notation 是未来的标准化，目前还有很多浏览器厂商不支持这个标准。根据测试和网上所知 目前只有 Chrome 、 Opera 支持，相信很快其他浏览器也会被支持，因为真的很有用。比如像人人网、微信网页版 都使用了这种技术，给用户带来了极高的体验。 在chrome console所知 notification拥有一个构造函数 具备以下的一些属性和方法 Notification &#123;icon: "", tag: "", body: "I'm an enginneer!", lang: "", dir: "auto"…&#125; body: "I'm an enginneer!" dir: "auto" icon: "" lang: "" onclick: null onclose: null onerror: null onshow: null tag: "" title: "Hello Notification" __proto__: Notification close: function close() &#123; [native code] &#125; arguments: null caller: null length: 0 name: "close" __proto__: function Empty() &#123;&#125; &lt; function scope &gt; constructor: function Notification() &#123; [native code] &#125; arguments: null caller: null length: 1 name: "Notification" permission: "default" prototype: Notification requestPermission: function requestPermission() &#123; [native code] &#125; toString: function toString() &#123; [native code] &#125; __proto__: function EventTarget() &#123; [native code] &#125; &lt; function scope &gt; __proto__: EventTarget 构造函数一共有2个参数 一个是title 另一个则是配置项 如下 属性 含义 默认值 dir 未知 auto lang 应该是国际化用的 null body 通知内容 null tag 标记/ID null icon 图标 异常显示 null Permission查看权限值 Notification.permission "default" permission 是一个静态属性 这个属性比较特殊是不可以手动去修改值的，只能用户通过授权提示来控制，他的值一共有3个如下 default 拒绝 denied 用户不需要通知功能 granted 启动通知了 要使用通知 必须要得到用户的授权后才可以使用，使用 Notification.requestPermission() 向用户请求通知授权 会出现一个是否确认授权的确认框，已经启动通知了将被忽略。 new Notification( 'notifi' ,&#123; body : '这是一个优雅的提醒' , icon : 'http://blog.peachyy.com/public/images/logo.png' &#125;); 执行代码后 会在右下角弹出一个浏览器级别的通知框 demo地址： http://cqweclick.github.io/notification.html</div><div class="post-footer clearfix"> <a href="/2015/07/21/browerNotification/" class="post-more waves-effect waves-button waves-light">阅读更多</a></div></article></li></ul><nav id="page-nav"><div class="inner"> <a class="extend prev" rel="prev" href="/page/2/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/">下一页</a></div></nav></div></main><div class="mask" id="mask"></div><a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a><script>var BLOG_SHARE={title:"笑松小站",pic:"/assets/images/logo.png",summary:document.getElementsByName("summary")[0].content,url:"http://blog.seoui.com/page/3/index.html"}</script><div class="global-share" id="global-share"><div class="tit">分享到：</div><ul class="reset share-icons"><li><a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina"><i class="icon icon-weibo"></i></a></li><li><a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin"><i class="icon icon-weixin"></i></a></li><li><a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq"><i class="icon icon-qq"></i></a></li><li><a class="facebook share-sns" href="javascript:;" data-title=" facebook" data-service="fb"><i class="icon icon-facebook"></i></a></li><li><a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter"><i class="icon icon-twitter"></i></a></li><li> <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">豆</a></li></ul></div><script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script><script src="/assets/scripts/main.js"></script><div class="search-panel" id="search-panel"><ul class="search-result" id="search-result"></ul></div><script type="text/template" id="search-tpl">
<li class="item">
    <a href="/{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</script><script src="/assets/scripts/search.js"></script><script src="//cdn.bootcss.com/jquery/1.12.3/jquery.min.js"></script><script src="/assets/fancybox/jquery.fancybox.js"></script><script type="text/javascript">var imgArr=$("#post-content img");if(null!=imgArr&&imgArr.length>0){for(var i=0,len=imgArr.length;i<len;i++){var src=imgArr.eq(i).attr("src"),title=imgArr.eq(i).attr("alt");imgArr.eq(i).replaceWith("<a href='"+src+"' title='"+title+"' rel='fancy-group' class='fancy-ctn fancybox'><img src='"+src+"' title='"+title+"'></a>")}$("#post-content .fancy-ctn").fancybox()}</script></body></html>