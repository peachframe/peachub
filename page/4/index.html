<!DOCTYPE html><html><head><meta charset="utf-8"><title>笑松小站 | 写我喜欢 读我所爱</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="undefined"><meta name="description" content="个人博客,陶小松,笑松,笑松小站,笑松的小站,笑松博客,笑松的博客"><meta property="og:type" content="website"><meta property="og:title" content="笑松小站"><meta property="og:url" content="http://blog.seoui.com/page/4/index.html"><meta property="og:site_name" content="笑松小站"><meta property="og:description" content="个人博客,陶小松,笑松,笑松小站,笑松的小站,笑松博客,笑松的博客"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="笑松小站"><meta name="twitter:description" content="个人博客,陶小松,笑松,笑松小站,笑松的小站,笑松博客,笑松的博客"><link rel="alternative" href="/atom.xml" title="笑松小站" type="application/atom+xml"><link rel="alternative" href="/sitemap.xml" title="笑松小站" type="application/atom+xml"><meta name="summary" content="个人博客,陶小松,笑松,笑松小站,笑松的小站,笑松博客,笑松的博客"><meta http-equiv="pragma" content="no-cache"><link rel="shortcut icon" href="/assets/images/favicon.ico"><link rel="stylesheet" href="/assets/styles/style.css"></head><body><div id="loading" class="active"></div><nav id="menu"><div class="inner flex-row-vertical"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off"><i class="icon icon-lg icon-close"></i></a><div class="brand-wrap"><div class="brand"> <a href="/" class="avatar"><img src="/assets/images/logo.png"></a><hgroup class="introduce"><h5 class="nickname"></h5><div class="email">写我喜欢 读我所爱</div></hgroup></div></div><ul class="nav flex-col"><li class="waves-block waves-effect"><a href="/"><i class="icon icon-lg icon-home"></i> Home</a></li><li class="waves-block waves-effect"><a href="/archives"><i class="icon icon-lg icon-archives"></i> Archives</a></li><li class="waves-block waves-effect"><a href="/tags"><i class="icon icon-lg icon-tags"></i> Tags</a></li><li class="waves-block waves-effect"><a href="/guestbook"><i class="icon icon-lg icon-book"></i> About</a></li><li class="waves-block waves-effect"><a href="/links"><i class="icon icon-lg icon-links"></i> Links</a></li></ul><footer class="footer"><p> <a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0;vertical-align:middle" src="/assets/images/cc-by-nc-nd.svg"></a></p><p>笑松小站 &copy; 2014~2016.</p><p>All Rights Reserved.</p><p><a href="/atom.xml" target="_blank" class="rss" style="position:inherit" title="rss"><i class="icon icon-2x icon-rss-square"></i></a><a href="/sitemap.xml" target="_blank" class="sitemap" style="color:#E64A19" title="sitemap"><i class="icon icon-2x icon-sitemap"></i></a></p></footer></div></nav><main id="main"><header class="header" id="header"><div class="flex-row"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle"><i class="icon icon-lg icon-navicon"></i></a><div class="flex-col header-title ellipsis">笑松小站</div><div class="search-wrap" id="search-wrap"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back"><i class="icon icon-lg icon-chevron-left"></i></a> <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search"><i class="icon icon-lg icon-search"></i></a></div><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-share"><i class="icon icon-lg icon-share-alt"></i></a></div></header><header class="content-header"><div class="container"><h1 class="author">笑松小站</h1><h5 class="subtitle">写我喜欢 读我所爱</h5></div></header><div class="container body-wrap"><ul class="post-list"><li class="post-list-item"><article id="post-lovewhat" class="article article-type-post" itemprop="blogPost"><h3 class="post-title" itemprop="name"> <a class="post-title-link" href="/2015/07/21/lovewhat/">爱是什么</a></h3><div class="post-meat flex-row"><div class="flex-col"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/爱是什么/">爱是什么</a></li></ul></div> <time datetime="2015-07-20T16:00:00.000Z" itemprop="datePublished" class="post-tiem">2015-07-21</time></div><div class="post-content" id="post-content" itemprop="postContent"> 多年后 偶尔会想起曾经是如此放松的快乐。 爱 是什么 爱 怎样才算爱 是爱吗 过了很久 已经完全忘记 如果没有爱 能活下去吗 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;写于不知道第几次回想曾经的快乐 &gt;</div><div class="post-footer clearfix"> <a href="/2015/07/21/lovewhat/" class="post-more waves-effect waves-button waves-light">阅读更多</a></div></article></li><li class="post-list-item"><article id="post-mongoEVcreate" class="article article-type-post" itemprop="blogPost"><h3 class="post-title" itemprop="name"> <a class="post-title-link" href="/2015/07/15/mongoEVcreate/">mongo[一] @环境搭建</a></h3><div class="post-meat flex-row"><div class="flex-col"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MongoDB/">MongoDB</a></li></ul></div> <time datetime="2015-07-14T16:00:00.000Z" itemprop="datePublished" class="post-tiem">2015-07-15</time></div><div class="post-content" id="post-content" itemprop="postContent"> 之前研究过一个Nosql数据库 redis 性能真的很好。不用为数据结构的标准规范为烦恼，这也许就是K V结构的真正意义。 mongo也是一种Nosql数据库 但它是基于文档的方式。听起来感觉比redis更好操作 也是当前nosql 比较优的产品，当然redis也是非常优秀的，客户量也很大，所以在这里记录我对mongo的一些使用经历。 mongo几乎支持所有的操作系统，Window、Linux、Mac、Solaris 官方比较建议在linux中使用 具体原因不知。为了方便 这里是使用Window。 下载 在 https://www.mongodb.org/downloads 这里使用的版本是2.0.8 for window 附上链接-&gt; http://share.weiyun.com/0d378b0bee389ea583025d9728a5bea0 这是一个ZIP版本,把文件解压到 E:\Dev\ 并把目录名称改为 mongodb 使用命令行进入 E:\Dev\mongodb\bin 目录 也可以把这个加入到计算机的path 加入已经成功把 E:\Dev\mongodb\bin 加入计算机path E:\Dev\mongodb&gt;mongod --version db version v2.0.8-rc1-pre-, pdfile version 4.5 Wed Jul 15 17:24:12 git version: 1d3d3ba938b9ac0d627fd8039ad8aee79c6968c4 输入命令 mongod –version出现上面的回复。则说明环境安装成功了。 mongod具有很多命令 使用 mongod --help 可以查看到mongod具备的所有命令。下面是命令的详细说明摘自网络 基本配置 -------------------------------------------------------------------------------- --quiet # 安静输出 --port arg # 指定服务端口号，默认端口27017 --bind_ip arg # 绑定服务IP，若绑定127.0.0.1，则只能本机访问，不指定默认本地所有IP --logpath arg # 指定MongoDB日志文件，注意是指定文件不是目录 --logappend # 使用追加的方式写日志 --pidfilepath arg # PID File 的完整路径，如果没有设置，则没有PID文件 --keyFile arg # 集群的私钥的完整路径，只对于Replica Set 架构有效 --unixSocketPrefix arg # UNIX域套接字替代目录,(默认为 /tmp) --fork # 以守护进程的方式运行MongoDB，创建服务器进程 --auth # 启用验证 --cpu # 定期显示CPU的CPU利用率和iowait --dbpath arg # 指定数据库路径 --diaglog arg # diaglog选项 0=off 1=W 2=R 3=both 7=W+some reads --directoryperdb # 设置每个数据库将被保存在一个单独的目录 --journal # 启用日志选项，MongoDB的数据操作将会写入到journal文件夹的文件里 --journalOptions arg # 启用日志诊断选项 --ipv6 # 启用IPv6选项 --jsonp # 允许JSONP形式通过HTTP访问（有安全影响） --maxConns arg # 最大同时连接数 默认2000 --noauth # 不启用验证 --nohttpinterface # 关闭http接口，默认关闭27018端口访问 --noprealloc # 禁用数据文件预分配(往往影响性能) --noscripting # 禁用脚本引擎 --notablescan # 不允许表扫描 --nounixsocket # 禁用Unix套接字监听 --nssize arg (=16) # 设置信数据库.ns文件大小(MB) --objcheck # 在收到客户数据,检查的有效性， --profile arg # 档案参数 0=off 1=slow, 2=all --quota # 限制每个数据库的文件数，设置默认为8 --quotaFiles arg # number of files allower per db, requires --quota --rest # 开启简单的rest API --repair # 修复所有数据库run repair on all dbs --repairpath arg # 修复库生成的文件的目录,默认为目录名称dbpath --slowms arg (=100) # value of slow for profile and console log --smallfiles # 使用较小的默认文件 --syncdelay arg (=60) # 数据写入磁盘的时间秒数(0=never,不推荐) --sysinfo # 打印一些诊断系统信息 --upgrade # 如果需要升级数据库 * Replicaton 参数 -------------------------------------------------------------------------------- --fastsync # 从一个dbpath里启用从库复制服务，该dbpath的数据库是主库的快照，可用于快速启用同步 --autoresync # 如果从库与主库同步数据差得多，自动重新同步， --oplogSize arg # 设置oplog的大小(MB) * 主/从参数 -------------------------------------------------------------------------------- --master # 主库模式 --slave # 从库模式 --source arg # 从库 端口号 --only arg # 指定单一的数据库复制 --slavedelay arg # 设置从库同步主库的延迟时间 * Replica set(副本集)选项： -------------------------------------------------------------------------------- --replSet arg # 设置副本集名称 * Sharding(分片)选项 -------------------------------------------------------------------------------- --configsvr # 声明这是一个集群的config服务,默认端口27019，默认目录/data/configdb --shardsvr # 声明这是一个集群的分片,默认端口27018 --noMoveParanoia # 关闭偏执为moveChunk数据保存 要启动数据库 必须要为mongo指定一个数据库数据文件的存放的目录 需要使用 mongod --dbpath 命令来完成，在d:\dev\ 创建一个mongodbDATA文件夹 用来存储mongo的数据库文件 mongod --dbpath E:\Dev\mongodbDATA Wed Jul 15 17:35:26 [initandlisten] MongoDB starting : pid=9368 port=27017 dbpat h=E:\Dev\mongodbDATA 64-bit host=pc-PC Wed Jul 15 17:35:26 [initandlisten] db version v2.0.8-rc1-pre-, pdfile version 4 .5 Wed Jul 15 17:35:26 [initandlisten] git version: 1d3d3ba938b9ac0d627fd8039ad8aee 79c6968c4 Wed Jul 15 17:35:26 [initandlisten] build info: windows sys.getwindowsversion(ma jor=6, minor=1, build=7601, platform=2, service_pack='Service Pack 1') BOOST_LIB _VERSION=1_42 Wed Jul 15 17:35:26 [initandlisten] options: &#123; dbpath: "E:\Dev\mongodbDATA" &#125; Wed Jul 15 17:35:26 [initandlisten] journal dir=E:/Dev/mongodbDATA/journal Wed Jul 15 17:35:26 [initandlisten] recover : no journal files present, no recov ery needed Wed Jul 15 17:35:26 [initandlisten] waiting for connections on port 27017 Wed Jul 15 17:35:26 [websvr] admin web console waiting for connections on port 2 8017 到这里 mongo数据库算是启动OK了。 注意控制台最后两句Log Wed Jul 15 17:35:26 [initandlisten] waiting for connections on port 27017 Wed Jul 15 17:35:26 [websvr] admin web console waiting for connections on port 28017 数据库连接端口27017 数据库web控制台端口28017 既然是web应该可以使用浏览器访问试试。 http://localhost:28017/ 能访问成功能证明我们的数据库是真的启动成功了。 下面将使用客户端连接数据库试试 新开一个CMD命令行窗口 输入 mongo 命令 mongodb会自动连接到test数据库 如下所示 C:\Users\pc&gt;mongo MongoDB shell version: 2.0.8-rc1-pre- connecting to: test &gt; 说明连接数据库服务器成功了。 环境搭建非常简单。需要熟悉一个mongod的一些常用命令 为后续更深入的了解做铺垫。</div><div class="post-footer clearfix"> <a href="/2015/07/15/mongoEVcreate/" class="post-more waves-effect waves-button waves-light">阅读更多</a></div></article></li><li class="post-list-item"><article id="post-ReadisStudy7" class="article article-type-post" itemprop="blogPost"><h3 class="post-title" itemprop="name"> <a class="post-title-link" href="/2015/07/14/ReadisStudy7/">redis客户端 for java</a></h3><div class="post-meat flex-row"><div class="flex-col"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/">Redis</a></li></ul></div> <time datetime="2015-07-13T16:00:00.000Z" itemprop="datePublished" class="post-tiem">2015-07-14</time></div><div class="post-content" id="post-content" itemprop="postContent"> 当然在数据中直接操作 redis 命令是没有什么价值和意义的，之所以使用她 是让她为我们的应用提供数据存储服务，让客户感受到价值所在。 redis她拥有很多种客户端连接工具 她几乎支持所有语言，比如 c , c# , c++ , Clojure , Common Lisp , d , Java , ruby , php ….等等。 下面主要描述一下 java 语言对redis的支持。单单只是 java 语言的客户端就有好多种，比如 Jedis , lettuce , aredis , JRedis 等。都是由众多的开发者贡献出来的，将来肯定会越来越多、就当前来说，Jedis lettuce都是比较常用的，其他这么多得客户端连接工具，使用方法都差不多的。所以一般只要能使用一个其他的也是OK的。最喜欢用的还是 Jedis 所以以下的示例代码中也将会是使用 Jedis 连接数据库。 maven依赖 &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; 帮助类 DButi.java public class DButil &#123; //在 org.apache.commons.pool.impl.GenericObjectPool 可以看到一些参数的默认值 //主机IP private static final String HOST= "localhost" ; //端口 private static final Integer PORT= 6379 ; //认证密码 private static final String AUTH_PAS= "xstao" ; //最大活动数目 private static final Integer MAX_ACTIVE = 20 ; //指定pool池 最多有多少个状态为idle private static final Integer MAX_IDLE= 100 ; //最长等待时间 毫秒 private static final Integer MAX_WAIT= 5000 ; //超时 private static final Integer TIME_OUT= 5000 ; private static JedisPool poolInstance= null ; /*** * 获取jedis 池实例对象 * @date 2015年7月14日 上午11:38:15 * @author xs Tao * @return */ public static JedisPool getJedisPoolInstance () &#123; if (poolInstance== null )&#123; //连接redis数据库 的参数对象 JedisPoolConfig config= new JedisPoolConfig(); config.setMaxActive(MAX_ACTIVE); config.setMaxWait(MAX_WAIT); config.setMaxIdle(MAX_IDLE); //创建池 拥有多个构造函数 //如果是默认的端口号 也可以使用默认端口号的构造函数。就连主机也是可以默认的。 poolInstance= new JedisPool(config, HOST, PORT, TIME_OUT, AUTH_PAS); &#125; return poolInstance; &#125; public static Jedis getJedis () &#123; if (poolInstance== null )&#123; DButil.getJedisPoolInstance(); &#125; //从池连接中 获取一个jedis资源 Jedis jedis= poolInstance.getResource(); return jedis; &#125; /** * 销毁jedis连接 * @date 2015年7月14日 上午11:43:03 * @author xs Tao * @param jedis */ public static void destory (Jedis jedis) &#123; if (poolInstance!= null &amp;&amp; jedis!= null )&#123; poolInstance.returnResource(jedis); &#125; &#125; &#125; 由于redis是使用K V来存储 所以会存在大量的 难以维护的K 一般会定义个生产KEY的类。用来定义系统K的生成规则 KeyUtils.java public class KeyUtils &#123; static String UID= "demo:uid" ; static String UID_AUTO_NUM= "demo-uid-index" ; public static String getUID (String uid) &#123; return UID.concat(uid); &#125; &#125; 用户实体类 public class User implements java . io . Serializable &#123; /** * */ private static final long serialVersionUID = 1L ; private String id; private String name; private String password; private String age; private String sex; /** * @return the id */ public String getId () &#123; return id; &#125; /** * @param id the id to set */ public void setId (String id) &#123; this .id = id; &#125; /** * @return the name */ public String getName () &#123; return name; &#125; /** * @param name the name to set */ public void setName (String name) &#123; this .name = name; &#125; /** * @return the password */ public String getPassword () &#123; return password; &#125; /** * @param password the password to set */ public void setPassword (String password) &#123; this .password = password; &#125; /** * @return the age */ public String getAge () &#123; return age; &#125; /** * @param age the age to set */ public void setAge (String age) &#123; this .age = age; &#125; /** * @return the sex */ public String getSex () &#123; return sex; &#125; /** * @param sex the sex to set */ public void setSex (String sex) &#123; this .sex = sex; &#125; public Map&lt;String, String&gt; toMap () &#123; Map&lt;String, String&gt; map= new HashMap&lt;String, String&gt;(); map.put( "id" , this .id); map.put( "name" , this .name); map.put( "password" , this .password); map.put( "age" , this .age); map.put( "sex" , this .sex); return map; &#125; &#125; 一个测试类 test.java public class test &#123; public static void main (String[] args) &#123; Jedis jedis=DButil.getJedis(); String uid=String.valueOf(jedis.incr(KeyUtils.UID_AUTO_NUM)); User user= new User(); user.setAge( "23" ); user.setId(uid); user.setName( "happy" ); user.setPassword( "5757124" ); user.setSex( "男" ); jedis.hmset(KeyUtils.getUID(uid),user.toMap()); System.out.println(jedis.hget(KeyUtils.getUID(uid), "name" )); &#125; &#125; 还有一个优秀封装redis客户端的项目 叫做 http://projects.spring.io/spring-data-redis/ 官方称在将来会兼容所有的redis java语言客户端 示例代码 https://github.com/peachyy/weclickSrc/tree/master/rs-parent/rs-redis</div><div class="post-footer clearfix"> <a href="/2015/07/14/ReadisStudy7/" class="post-more waves-effect waves-button waves-light">阅读更多</a></div></article></li><li class="post-list-item"><article id="post-fillingLookLook" class="article article-type-post" itemprop="blogPost"><h3 class="post-title" itemprop="name"> <a class="post-title-link" href="/2015/06/19/fillingLookLook/">当你想放弃的时候就看看这个吧</a></h3><div class="post-meat flex-row"><div class="flex-col"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/坚持/">坚持</a></li></ul></div> <time datetime="2015-06-18T16:00:00.000Z" itemprop="datePublished" class="post-tiem">2015-06-19</time></div><div class="post-content" id="post-content" itemprop="postContent"> 迷路、想放弃、对生活绝望时看看这个.肯定会好一点的</div><div class="post-footer clearfix"> <a href="/2015/06/19/fillingLookLook/" class="post-more waves-effect waves-button waves-light">阅读更多</a></div></article></li><li class="post-list-item"><article id="post-ReadisStudy3-hash" class="article article-type-post" itemprop="blogPost"><h3 class="post-title" itemprop="name"> <a class="post-title-link" href="/2015/06/11/ReadisStudy3-hash/">Redis[三] @Hash 哈希</a></h3><div class="post-meat flex-row"><div class="flex-col"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/">Redis</a></li></ul></div> <time datetime="2015-06-10T16:00:00.000Z" itemprop="datePublished" class="post-tiem">2015-06-11</time></div><div class="post-content" id="post-content" itemprop="postContent"> Redis 的哈希值是字符串字段和字符串值之间的映射，所以他们是表示对象的完美数据类型 在Redis中的哈希值，可存储超过400十亿键值对。 redis 提供了2套操纵 一种是批量 一种是非批量 假设需要存储一个用户信息 批量操作 定义一个key为user1的hash 包含属性 name=xstao、age=22、sex=1、password=123 并获取user1中name的属性值 redis 127.0.0.1:6379[1]&gt; hmset user1 name xstao age 22 sex 1 password 123 OK redis 127.0.0.1:6379[1]&gt; hmget user1 name 1) "xstao" 获取user1的全部key 、 value、全部的key value redis 127.0.0.1:6379[1]&gt; hgetall user1 1) "name" 2) "xstao" 3) "age" 4) "22" 5) "sex" 6) "1" 7) "password" 8) "123" redis 127.0.0.1:6379[1]&gt; hkeys user1 1) "name" 2) "age" 3) "sex" 4) "password" redis 127.0.0.1:6379[1]&gt; hvals user1 1) "xstao" 2) "22" 3) "1" 4) "123" 获取user1这个hash的字段数量 redis 127.0.0.1:6379[1]&gt; hlen user1 (integer) 4 为hash user1添加一个字段 并查看添加后的数据结构 redis 127.0.0.1:6379[1]&gt; hmset user1 ext1 test OK redis 127.0.0.1:6379[1]&gt; hgetall user1 1) "name" 2) "xstao" 3) "age" 4) "22" 5) "sex" 6) "1" 7) "password" 8) "123" 9) "ext1" 10) "test" 更新key为user1 sex的值为0 并返回赋值成功后的新值 redis 127.0.0.1:6379[1]&gt; hset user1 sex 0 (integer) 0 非批量 从命令格式上来看批量都加了 m 而非批量都没有 比如批量 hmset 非批量 hset 定义一个哈希表user2 第一次执行成功 ，第二次执行批量添加失败了。因为hset仅支持单个添加 redis 127.0.0.1:6379[1]&gt; hset user2 name abc (integer) 1 redis 127.0.0.1:6379[1]&gt; hset user3 name abc age 2 (error) ERR wrong number of arguments for 'hset' command redis 127.0.0.1:6379[1]&gt; 其他一些常用命令命令 //判断user1中name是否存在 返回1表示已存在 返回0标识没有这个name字段key redis 127.0.0.1:6379[1]&gt; hexists user1 name (integer) 1 //针对user1 中age(年龄)字段自增2 返回自增后的值 redis 127.0.0.1:6379[1]&gt; hincrby user1 age 2 (integer) 24 //针对user1 中age(年龄)字段浮点数自增2.5 返回自增后的值 redis 127.0.0.1:6379[1]&gt; hincrbyfloat user1 age 2.5 "28.5"</div><div class="post-footer clearfix"> <a href="/2015/06/11/ReadisStudy3-hash/" class="post-more waves-effect waves-button waves-light">阅读更多</a></div></article></li><li class="post-list-item"><article id="post-ReadisStudy6-sets" class="article article-type-post" itemprop="blogPost"><h3 class="post-title" itemprop="name"> <a class="post-title-link" href="/2015/06/11/ReadisStudy6-sets/">Redis[六] @sets 有序集合</a></h3><div class="post-meat flex-row"><div class="flex-col"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/">Redis</a></li></ul></div> <time datetime="2015-06-10T16:00:00.000Z" itemprop="datePublished" class="post-tiem">2015-06-11</time></div><div class="post-content" id="post-content" itemprop="postContent"> 其实redis的有序和无序集合有点类似。差别就在于有序用于一个排序的规则。官方称它为 score 分数。默认情况下 分数越小越靠前 zadd 语法 ZADD key score1 member1 [score2 member2] 添加一个或者多个成员到有序集合，如果值已经存在于这个集合中就更新这个值得分数。 zrange 语法 ZRANGE key start stop [WITHSCORES] 如果加了参数 withscores 表示 展示列表的时候需要打印值得分数。 返回指定一个索引的范围 的有序集合。stop为-1 表示返回全部索引的数据。 如下示例 演示了 添加一个myzset1集合。并使用zrange命令 展示所有的myzset1集合列表 redis 127.0.0.1:6379&gt; zadd myzset1 0 a (integer) 1 redis 127.0.0.1:6379&gt; zadd myzset1 1 b 2 c 3 d (integer) 3 redis 127.0.0.1:6379&gt; zrange myzset1 0 -1 1) "a" 2) "b" 3) "c" 4) "d" redis 127.0.0.1:6379&gt; zrem 语法:ZREM key member [member …] 从有序集合中删除一个或多个成员 返回值为删除成功的个数。 zremrangebyrank 语法 zremrangebyrank zset 2 3 按索引（下标） 按索引删除 zremrangebyscore 语法 zremrangebyscore zset 2 3 按分数、也可以理解为按顺序。 按分数/顺序删除 zrank 语法 ZRANK key member 返回有序集合中元素 指定元素的索引 redis 127.0.0.1:6379&gt; zrank myzset1 d (integer) 1 zrevrange 语法 zrevrange zset start stop [widthscores] 倒序输出集合 zcount 语法 zcount zset startScope stopScope 返回zset集合中 分数区间个数 如：展示了分数为0-5之前的个数 redis 127.0.0.1:6379&gt; zcount myzset1 0 5 (integer) 2 redis 127.0.0.1:6379&gt; zcard 语法 zcard myzset1 返回集合中元素的个数 还有很多常用的命令 不再一一列举 。可以到 http://www.yiibai.com/redis/redis_sorted_sets.html //redis.io 查询资料。</div><div class="post-footer clearfix"> <a href="/2015/06/11/ReadisStudy6-sets/" class="post-more waves-effect waves-button waves-light">阅读更多</a></div></article></li><li class="post-list-item"><article id="post-ReadisStudy5-set" class="article article-type-post" itemprop="blogPost"><h3 class="post-title" itemprop="name"> <a class="post-title-link" href="/2015/06/11/ReadisStudy5-set/">Redis[五] @Set 无序集合</a></h3><div class="post-meat flex-row"><div class="flex-col"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/">Redis</a></li></ul></div> <time datetime="2015-06-10T16:00:00.000Z" itemprop="datePublished" class="post-tiem">2015-06-11</time></div><div class="post-content" id="post-content" itemprop="postContent"> redis 提供了2种规则的 SET 集合 1、有序集合 2、无序集合。 sadd 添加 – 添加一个set key为set1 添加 a-e 当返回1表示添加成功，返回0或其他表示添加失败。 redis 127.0.0.1:6379&gt; sadd set1 a (integer) 1 redis 127.0.0.1:6379&gt; sadd set1 b (integer) 1 redis 127.0.0.1:6379&gt; sadd set1 c (integer) 1 redis 127.0.0.1:6379&gt; sadd set1 d (integer) 1 redis 127.0.0.1:6379&gt; sadd set1 e (integer) 1 redis 127.0.0.1:6379&gt; smembers 查看 这个set1的集合 使用命令 smembers 语法:smembers key 添加值一次添加a b c d e ，而返回给我们的value并非是添加顺序的列表。所以这是一个无序列表；结果如下。 redis 127.0.0.1:6379&gt; smembers set1 1) "a" 2) "d" 3) "b" 4) "c" 5) "e" redis 127.0.0.1:6379&gt; srem 删除 –删除set中的元素 命令 srem 语法: srem set value 如下试着删除set1中a元素。 redis 127.0.0.1:6379&gt; srem set1 a (integer) 1 redis 127.0.0.1:6379&gt; smembers set1 1) "d" 2) "b" 3) "c" 4) "e" redis 127.0.0.1:6379&gt; 从结果可以看出执行srem命令后 返回1 同样 表示删除成功，成功删除1个元素。当然可以同时删除多个元素 如 srem set1 b c d 返回的数值是多少就表示成功删除了多少个元素。 spop 随机弹出一个元素 这个命令的效果是删除源集合的一个元素。并将这个元素返回。 如 spop set1 sdiff 取差集 以set1为基准 获取2个集合中 不一样的数据。语法: sdiff set1 set2 redis 127.0.0.1:6379&gt; smembers set1 1) "d" 2) "b" 3) "c" 4) "e" redis 127.0.0.1:6379&gt; sadd set2 a b d f (integer) 4 redis 127.0.0.1:6379&gt; sdiff set1 set2 1) "e" 2) "c" redis 127.0.0.1:6379&gt; 结果打印e c 因为以set1为基准 只有c e 在set2没有。所以差集就是c e sdiffstore 获取差集并存储在一个集合中 语法: sdiffstore dist set1 set2 同样是以set1(第一个集合)为基准 返回被存储集合长度 redis 127.0.0.1:6379&gt; sdiffstore dist set1 set2 (integer) 2 redis 127.0.0.1:6379&gt; smembers dist 1) "e" 2) "c" redis 127.0.0.1:6379&gt; sinter 获取交集 语法 sinter set1 set2 以set1(第一个集合)为基准获取2个集合的相同的数据。返回值为 2个集合的交集 sinterstore 获取交集并把返回值存储在指定的集合中。语法: sinterstore dist set1 set2 返回值为返回新集合的长度 redis 127.0.0.1:6379&gt; sinter set1 set2 1) "d" 2) "b" redis 127.0.0.1:6379&gt; sinterstore dist2 set1 set2 (integer) 2 redis 127.0.0.1:6379&gt; smembers dist2 1) "b" 2) "d" redis 127.0.0.1:6379&gt; sunion 取并集 语法:sunion set1 set2 简而言之就是把2个集合合并，并且排除相同的数据。 sunion 取并集 、而且把结果存储在指定的对象中。语法: sunionstore dist3 set1 set2 redis 127.0.0.1:6379&gt; sunion set1 set2 1) "f" 2) "b" 3) "d" 4) "c" 5) "a" 6) "e" 还有一些常用的命令如下: smove 语法 smove set1 set b 将第1个集合里面的指定元素移动到第2个集合中去。注意是移动 也就是说第1个集合中的被移动的数据将会被删除。 scard 语法 · scard set1 获取集合元素的个数 sismember 语法 sismember set a 试着判断 a 是否存在于set中 返回值 1标识存在。0标识不存在 srandmember 语法 srandmember set 随机返回集合中的一个元素 。注意只是返回并不会移动源集合的数据。</div><div class="post-footer clearfix"> <a href="/2015/06/11/ReadisStudy5-set/" class="post-more waves-effect waves-button waves-light">阅读更多</a></div></article></li><li class="post-list-item"><article id="post-ReadisStudy4-list" class="article article-type-post" itemprop="blogPost"><h3 class="post-title" itemprop="name"> <a class="post-title-link" href="/2015/06/11/ReadisStudy4-list/">Redis[四] @List 列表</a></h3><div class="post-meat flex-row"><div class="flex-col"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/">Redis</a></li></ul></div> <time datetime="2015-06-10T16:00:00.000Z" itemprop="datePublished" class="post-tiem">2015-06-11</time></div><div class="post-content" id="post-content" itemprop="postContent"> http://redisdoc.com/s Redis 列表是简单的字符串列表，排序插入顺序。您可以在头部或列表的尾部Redis的列表添加元素。 1、使用 lpush 命令 添加一个list1 拥有元素 1 2 3 并返回list1的长度 注意 取出顺序是 先进后出 2、并使用 lrange 命令获取list中的指定索引元素 0 -1表示从0开始 到len结束 格式：LRANGE key start stop 3、 llen 命令取得list1长度 redis 127.0.0.1:6379&gt; lpush list1 1 2 3 (integer) 3 redis 127.0.0.1:6379&gt; lrange list1 0 -1 1) "3" 2) "2" 3) "1" redis 127.0.0.1:6379&gt; llen list1 (integer) 3 redis 127.0.0.1:6379&gt; 这种很笨的先进后出做法确实不够好，那么我想最后添加的最先出来怎么办呢？当然了 效率如此高的redis肯定是ok的。 使用 lpushx 命令 可以添加到当前列表的最前面 输出结果可以看到我们最后添加的4被排到了最前面去了。 redis 127.0.0.1:6379&gt; lpushx list1 4 (integer) 4 redis 127.0.0.1:6379&gt; lrange list1 0 -1 1) "4" 2) "3" 3) "2" 4) "1" 根据指定键 指定索引获取列表中的数据 注意 索引是从0开始的。 redis 127.0.0.1:6379&gt; lindex list1 0 "4" 使用 linsert key before|after oldval newval 命令可以实现向指定key 指定一个元素值得前面 | 后面 插入一个值 如下实现的是 向list1中元素4之前插入a 并遍历元素 然后 又向元素4之后插入b 并遍历显示元素 redis 127.0.0.1:6379&gt; linsert list1 before 4 a (integer) 5 redis 127.0.0.1:6379&gt; lrange list1 0 -1 1) "a" 2) "4" 3) "3" 4) "2" 5) "1" redis 127.0.0.1:6379&gt; linsert list1 after 4 b (integer) 6 redis 127.0.0.1:6379&gt; lrange list1 0 -1 1) "a" 2) "4" 3) "b" 4) "3" 5) "2" 6) "1" LPOP key 删除列表中的第一个元素 并返回。 redis 127.0.0.1:6379&gt; lpop list1 "a" LREM key count value 从列表中删除元素 count表示删除的个数 value表示删除的需要删除的元素值 如下 先添加b list1列表中就具有3个b 那么我们就执行 lrem list1 2 b 删除2个b。 redis 127.0.0.1:6379&gt; linsert list1 after 3 b (integer) 6 redis 127.0.0.1:6379&gt; lrange list1 0 -1 1) "4" 2) "b" 3) "3" 4) "b" 5) "2" 6) "1" redis 127.0.0.1:6379&gt; linsert list1 after 2 b (integer) 7 redis 127.0.0.1:6379&gt; lrange list1 0 -1 1) "4" 2) "b" 3) "3" 4) "b" 5) "2" 6) "b" 7) "1" redis 127.0.0.1:6379&gt; lrem list1 2 b (integer) 2 redis 127.0.0.1:6379&gt; lrange list1 0 -1 1) "4" 2) "3" 3) "2" 4) "b" 5) "1" LSET key index value 更新指定索引的值 如下是 为list1中索引为3的重新赋值为b2 redis 127.0.0.1:6379&gt; lrange list1 0 -1 1) "4" 2) "3" 3) "2" 4) "b" 5) "1" redis 127.0.0.1:6379&gt; lset list1 3 b2 OK redis 127.0.0.1:6379&gt; lrange list1 0 -1 1) "4" 2) "3" 3) "2" 4) "b2" 5) "1" ltrim命令可以实现为裁剪指定索引区间的数据 如下是裁剪list1 中1下标——2下标中的数据 redis 127.0.0.1:6379&gt; ltrim list1 1 2 OK redis 127.0.0.1:6379&gt; lrange list1 0 -1 1) "3" 2) "2" rpush为列表添加元素 并实现 先进先出 的原则 与lpush相反 如下先添加1 2 3 4 返回的顺序也是 1 2 3 4 redis 127.0.0.1:6379&gt; rpush list2 1 2 3 4 (integer) 4 redis 127.0.0.1:6379&gt; lrange list2 0 -1 1) "1" 2) "2" 3) "3" 4) "4" RPOP key取出列表中最后一个元素 如下可知 list2中最后一个元素是4 redis 127.0.0.1:6379&gt; rpop list2 "4" RPOPLPUSH source destination 删除最后一个元素的列表，将其附加到另一个列表并返回它 如下list3并没有声明。而是把list2的最后一个元素保存到了list3列表中 redis 127.0.0.1:6379&gt; rpoplpush list2 list3 "3" redis 127.0.0.1:6379&gt; lrange list3 0 -1 1) "3"</div><div class="post-footer clearfix"> <a href="/2015/06/11/ReadisStudy4-list/" class="post-more waves-effect waves-button waves-light">阅读更多</a></div></article></li><li class="post-list-item"><article id="post-oraclegeneraloption" class="article article-type-post" itemprop="blogPost"><h3 class="post-title" itemprop="name"> <a class="post-title-link" href="/2015/06/04/oraclegeneraloption/">oracle常用操作记录</a></h3><div class="post-meat flex-row"><div class="flex-col"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/oracle/">oracle</a></li></ul></div> <time datetime="2015-06-03T16:00:00.000Z" itemprop="datePublished" class="post-tiem">2015-06-04</time></div><div class="post-content" id="post-content" itemprop="postContent"> 有一个表名为tb，字段段名为name，数据类型nchar(20)。 假设字段数据为空，则不管改为什么字段类型，可以直接执行 alter table tb modify (name nvarchar2(20)); 假设字段有数据，则改为nvarchar2(20)可以直接执行 alter table tb modify (name nvarchar2(20)); 假设字段有数据，则改为varchar2(40)执行时会弹出“ORA-01439:要更改数据类型,则要修改的列必须为空”，这时要用下面方法来解决这个问题 修改原字段名name为name_tmp alter table tb rename column name to name_tmp; 增加一个和原字段名同名的字段name alter table tb add name varchar2(40); 将原字段name_tmp数据更新到增加的字段name update tb set name=trim(name_tmp); 更新完，删除原字段name_tmp alter table tb drop column name_tmp; 总结： 1、当字段没有数据或者要修改的新类型和原类型兼容时，可以直接modify修改。 2、当字段有数据并用要修改的新类型和原类型不兼容时，要间接新建字段来转移。</div><div class="post-footer clearfix"> <a href="/2015/06/04/oraclegeneraloption/" class="post-more waves-effect waves-button waves-light">阅读更多</a></div></article></li><li class="post-list-item"><article id="post-ReadisStudy2-string" class="article article-type-post" itemprop="blogPost"><h3 class="post-title" itemprop="name"> <a class="post-title-link" href="/2015/06/01/ReadisStudy2-string/">Redis[二] @String</a></h3><div class="post-meat flex-row"><div class="flex-col"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/">Redis</a></li></ul></div> <time datetime="2015-05-31T16:00:00.000Z" itemprop="datePublished" class="post-tiem">2015-06-01</time></div><div class="post-content" id="post-content" itemprop="postContent"> 启动数据库客户端 redis-cli.exe 在Redis 数据中目前拥有以下几种数据类型 String 字符串 Hashes 哈希 List 列表 set 无序集合 sets 有序集合 String 最常用过的数据类型 Redis提供一些命令来操作数据库 格式如: COMMAND KEY_NAME 设置一个key为cname ,value为123的数据 并获取cname的value redis 127.0.0.1:6379&gt; set cname 123 OK redis 127.0.0.1:6379&gt; get cname "123" redis 127.0.0.1:6379&gt; 删除key为cname的字符串数据 执行了2次 del cname 命令。第一次返回1 代表删除成功，第二次返回0代表删除失败 在redis中执行命令一般情况下如果返回0则 表示执行失败。当然特殊除外 最后在获取key为cname的值 因为被删除了 所以返回 nil redis 127.0.0.1:6379&gt; del cname (integer) 1 redis 127.0.0.1:6379&gt; del cname (integer) 0 redis 127.0.0.1:6379&gt; get cname (nil) redis 127.0.0.1:6379&gt; 其他一些常用命令 //重新定义个Key cname redis 127.0.0.1:6379&gt; set cname 123 OK //返回存储在指定键的值的序列化版本。 redis 127.0.0.1:6379&gt; dump cname "\x00\xc0&#123;\x06\x00\xde\x0f;a\xf5/[*" //检查该键是否存在 返回1表示存在 0表示不存在 redis 127.0.0.1:6379&gt; exists cname (integer) 1 //设置cname的过期时间为60秒 redis 127.0.0.1:6379&gt; expire cname 60 (integer) 1 //查看cname的过期剩余时间 redis 127.0.0.1:6379&gt; ttl cname (integer) 42 redis 127.0.0.1:6379&gt; ttl cname (integer) 40 //移除cname的过期剩余时间 那么cname将一直存在 redis 127.0.0.1:6379&gt; persist cname (integer) 1 //移除cname后，查看cname的过期为-1 表示一直存在了 redis 127.0.0.1:6379&gt; ttl cname (integer) -1 redis 127.0.0.1:6379&gt; ttl cname1 (integer) -1 //查看所有键 可以使用通配符 redis 127.0.0.1:6379&gt; keys c* 1) "cname" //随机返回一个键 redis 127.0.0.1:6379&gt; randomkey "cname" redis 127.0.0.1:6379&gt; randomkey "cname" //对cname进行重命名为cname2 redis 127.0.0.1:6379&gt; rename cname cname2 OK //我们查看了cname2在列表中。说明重命名成功了 redis 127.0.0.1:6379&gt; keys * 1) "money" 2) "name" 3) "cname2" //重命名不存在的key会出错 redis 127.0.0.1:6379&gt; rename cname55 cname2 (error) ERR no such key redis 127.0.0.1:6379&gt; renamenx cname55 cname2 (error) ERR no such key //查看cname2的数据类型 redis 127.0.0.1:6379&gt; type cname2 string redis 127.0.0.1:6379&gt;</div><div class="post-footer clearfix"> <a href="/2015/06/01/ReadisStudy2-string/" class="post-more waves-effect waves-button waves-light">阅读更多</a></div></article></li></ul><nav id="page-nav"><div class="inner"> <a class="extend prev" rel="prev" href="/page/3/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/">下一页</a></div></nav></div></main><div class="mask" id="mask"></div><a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a><script>var BLOG_SHARE={title:"笑松小站",pic:"/assets/images/logo.png",summary:document.getElementsByName("summary")[0].content,url:"http://blog.seoui.com/page/4/index.html"}</script><div class="global-share" id="global-share"><div class="tit">分享到：</div><ul class="reset share-icons"><li><a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina"><i class="icon icon-weibo"></i></a></li><li><a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin"><i class="icon icon-weixin"></i></a></li><li><a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq"><i class="icon icon-qq"></i></a></li><li><a class="facebook share-sns" href="javascript:;" data-title=" facebook" data-service="fb"><i class="icon icon-facebook"></i></a></li><li><a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter"><i class="icon icon-twitter"></i></a></li><li> <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">豆</a></li></ul></div><script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script><script src="/assets/scripts/main.js"></script><div class="search-panel" id="search-panel"><ul class="search-result" id="search-result"></ul></div><script type="text/template" id="search-tpl">
<li class="item">
    <a href="/{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</script><script src="/assets/scripts/search.js"></script><script src="/assets/fancybox/jquery.fancybox.pack.js"></script><script type="text/javascript">var imgArr=$("#post-content img");if(null!=imgArr&&imgArr.length>0){for(var i=0,len=imgArr.length;i<len;i++){var src=imgArr.eq(i).attr("src"),title=imgArr.eq(i).attr("alt");imgArr.eq(i).replaceWith("<a href='"+src+"' title='"+title+"' rel='fancy-group' class='fancy-ctn fancybox'><img src='"+src+"' title='"+title+"'></a>")}$("#post-content .fancy-ctn").fancybox()}</script></body></html>