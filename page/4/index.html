<!DOCTYPE html><html><head><meta charset="utf-8"><title>笑松小站 | 写我喜欢 读我所爱</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="笑松小站,写我喜欢 读我所爱,"><meta name="description" content="个人博客,陶小松,笑松,笑松小站,笑松的小站,笑松博客,笑松的博客,小松的网络日志,技术博客"><meta property="og:type" content="website"><meta property="og:title" content="笑松小站"><meta property="og:url" content="http://blog.seoui.com/page/4/index.html"><meta property="og:site_name" content="笑松小站"><meta property="og:description" content="个人博客,陶小松,笑松,笑松小站,笑松的小站,笑松博客,笑松的博客,小松的网络日志,技术博客"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="笑松小站"><meta name="twitter:description" content="个人博客,陶小松,笑松,笑松小站,笑松的小站,笑松博客,笑松的博客,小松的网络日志,技术博客"><link rel="alternative" href="/atom.xml" title="笑松小站" type="application/atom+xml"><link rel="alternative" href="/sitemap.xml" title="笑松小站" type="application/atom+xml"><meta name="summary" content="个人博客,陶小松,笑松,笑松小站,笑松的小站,笑松博客,笑松的博客,小松的网络日志,技术博客"><meta http-equiv="Pragma" content="no-cache"><meta http-equiv="Cache-Control" content="no-cache"><meta http-equiv="Content-Language" content="zh-CN"><meta http-equiv="Expires" content="0"><link rel="shortcut icon" href="/assets/images/favicon.ico"><link rel="stylesheet" href="/assets/styles/style.css"></head><body><div id="loading" class="active"></div><nav id="menu"><div class="inner flex-row-vertical"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off"><i class="icon icon-lg icon-close"></i></a><div class="brand-wrap"><div class="brand"> <a href="/" class="avatar"><img alt="笑松小站" src="/assets/images/logo.png"></a><hgroup class="introduce"><h5 class="nickname"></h5><div class="email">写我喜欢 读我所爱</div></hgroup></div></div><ul class="nav flex-col"><li class="waves-block waves-effect"><a href="/"><i class="icon icon-lg icon-home"></i> Home</a></li><li class="waves-block waves-effect"><a href="/archives"><i class="icon icon-lg icon-archives"></i> Archives</a></li><li class="waves-block waves-effect"><a href="/tags"><i class="icon icon-lg icon-tags"></i> Tags</a></li><li class="waves-block waves-effect"><a href="/guestbook"><i class="icon icon-lg icon-book"></i> About</a></li><li class="waves-block waves-effect"><a href="/links"><i class="icon icon-lg icon-links"></i> Links</a></li></ul><footer class="footer"><p> <a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0;vertical-align:middle" src="/assets/images/cc-by-nc-nd.svg"></a></p><p>笑松小站 &copy; 2014~2017.</p><p>All Rights Reserved.</p><p><a href="/atom.xml" target="_blank" class="rss" style="position:inherit" title="rss"><i class="icon icon-2x icon-rss-square"></i></a><a href="/sitemap.xml" target="_blank" class="sitemap" style="color:#E64A19" title="sitemap"><i class="icon icon-2x icon-sitemap"></i></a></p></footer></div></nav><main id="main"><header class="header" id="header"><div class="flex-row"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle"><i class="icon icon-lg icon-navicon"></i></a><div class="flex-col header-title ellipsis">笑松小站</div><div class="search-wrap" id="search-wrap"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back"><i class="icon icon-lg icon-chevron-left"></i></a> <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search"><i class="icon icon-lg icon-search"></i></a></div><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-share"><i class="icon icon-lg icon-share-alt"></i></a></div></header><header class="content-header"><div class="container"><h1 class="author">笑松小站</h1><h5 class="subtitle"> 写我喜欢 读我所爱</h5></div></header><div class="container body-wrap"><ul class="post-list"><li class="post-list-item"><article id="post-linux.general.command" class="article article-type-post" itemprop="blogPost"><h3 class="post-title" itemprop="name"> <a class="post-title-link" href="/2015/08/29/linux.general.command/">Linux常用命令</a></h3><div class="post-meat flex-row"><div class="flex-col"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul></div> <time datetime="2015-08-28T16:00:00.000Z" itemprop="datePublished" class="post-tiem">2015-08-29</time></div><div class="post-content" id="post-content" itemprop="postContent"> 首先介绍几个方便的操作 通配符 * 匹配任意字符 如 test* ? 匹配任意单个字符 如 te?t [] 匹配任意指定的字符 如myn[123] 匹配 myn1 、myn2 myn3 命令补全 在编写命令的时候 如mkdir命令 输入mk按下Tab键会把mk开头的所有命令显示出来。 当然也可以匹配文件 在使用过程中效率非常高。 命令历史 使用命令 history 可以查看当前用户键入过的所有命令。 使用 !! 命令可以执行上一次执行命令。 也可以使用 ! 跟上命令前缀或命令全名 会在历史记录中查找并执行命令。 常用命令 组合命令 以 ls 为例 ls -al 表示同时显示所有文件 并显示详细信息。 常用命令 ls 浏览 文件目录信息 默认是当前文件也可以使用参数 ls -a /etc/ 一些linux系统还支持 ll 命令 效果如ls命令，但ls是标准的命令所有linux系统都支持。 pwd 当前所在目录的路径 pwd cd 进入到指定的目录 /代表根目录 常用的文件系统操作 在介绍文件操作的命令之前介绍一下Linux的文件类型 d 目录文件。 l 符号链接(指向另一个文件,类似于瘟下的快捷方式)。 s 套接字文件。 b 块设备文件,二进制文件。 c 字符设备文件。 p 命名管道文件。 - 普通文件，或更准确地说，不属于以上几种类型的文件 mkdir 创建目录 mkdir ttt rmdir 删除目录 rmdir ttt file 显示文件的类型 touch 创建或更新文件 cp 复制文件 cp 需要复制的文件 新的文件名称 复制目录需要加上参数-r rm 删除文件 删除目录需要加参数-r -f参数可以不用确认 mv 移动文件 mv 文件 移动文件的目标位置 cat 查看文件内容 不分页 more 查看文件内容 分页 less 查看文件内容 分页 和more一样 head 查看文件指定前几行内容 如head -10 /etc/passwd 显示前10行内容 tail 查看文件指定后几行内容 如tail -10 /etc/passwd 显示后10行内容 方便的重定向功能 重定向分为 输入重定向、输出重定向、错误重定向。 如 cat test.txt&gt; testlog.txt 会把cat的结果重定向到testlog.txt文件中。会追加数据 cat test.txt &gt;&gt; testlog.txt 会把cat的结构重定向到testlog.txt文件中，会覆盖以前的数据。 管道操作 什么是管道? 我认为管道就是为一些结果做过滤操作的，比较实用。 | 表示管道连接符 如 ls -l | more 会分页显示ls的结果 ls -l |grep fff 会过滤出ls中包含fff的结果</div><div class="post-footer clearfix"> <a href="/2015/08/29/linux.general.command/" class="post-more waves-effect waves-button waves-light">阅读更多</a></div></article></li><li class="post-list-item"><article id="post-httpinfolist" class="article article-type-post" itemprop="blogPost"><h3 class="post-title" itemprop="name"> <a class="post-title-link" href="/2015/08/19/httpinfolist/">HTTP Header详细文档</a></h3><div class="post-meat flex-row"><div class="flex-col"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/">HTTP</a></li></ul></div> <time datetime="2015-08-18T16:00:00.000Z" itemprop="datePublished" class="post-tiem">2015-08-19</time></div><div class="post-content" id="post-content" itemprop="postContent"> HTTP（HyperTextTransferProtocol）即超文本传输协议，目前网页传输的的通用协议。HTTP协议采用了请求/响应模型，浏览器或其他客户端发出请求，服务器给与响应。就整个网络资源传输而言，包括message-header和message-body两部分。首先传递message- header，即http header消息 。http header 消息通常被分为4个部分：general header, request header, response header, entity header。但是这种分法就理解而言，感觉界限不太明确。根据维基百科对http header内容的组织形式，大体分为Request和Response两部分。 Requests部分 Header 含义 例子 Accept 指定客户端能够接收的内容类型 Accept: text/plain, text/html Accept-Charset 浏览器可以接受的字符编码集。 Accept-Charset: iso-8859-5 Accept-Encoding 指定浏览器可以支持的web服务器返回内容压缩编码类型。 Accept-Encoding: compress, gzip Accept-Language 浏览器可接受的语言 Accept-Language: en,zh Accept-Ranges 可以请求网页实体的一个或者多个子范围字段 Accept-Ranges: bytes Authorization HTTP授权的授权证书 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Cache-Control 指定请求和响应遵循的缓存机制 Cache-Control: no-cache Connection 表示是否需要持久连接。（HTTP 1.1默认进行持久连接） Connection: close Cookie |HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。| Cookie: $Version=1; Skin=new;| |Content-Length |请求的内容长度| Content-Length: 348| |Content-Type |请求的与实体对应的MIME信息 |Content-Type: application/x-www-form-urlencoded| |Date |请求发送的日期和时间 |Date: Tue, 15 Nov 2010 08:12:31 GMT| |Expect |请求的特定的服务器行为| Expect: 100-continue| |From |发出请求的用户的Email| From: user@email.com| |Host |指定请求的服务器的域名和端口号 |Host: www.zcmhi.com| |If-Match |只有请求内容与实体相匹配才有效| If-Match: “737060cd8c284d8af7ad3082f209582d”| |If-Modified-Since |如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码| If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT| |If-None-Match |如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变 |If-None-Match: “737060cd8c284d8af7ad3082f209582d”| |If-Range | 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag| If-Range: “737060cd8c284d8af7ad3082f209582d”| |If-Unmodified-Since | 只在实体在指定时间之后未被修改才请求成功 |If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT| |Max-Forwards |限制信息通过代理和网关传送的时间| Max-Forwards: 10| |Pragma |用来包含实现特定的指令| Pragma: no-cache| |Proxy-Authorization | 连接到代理的授权证书| Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==| |Range |只请求实体的一部分，指定范围| Range: bytes=500-999| |Referer |先前网页的地址，当前请求网页紧随其后,即来路 |Referer: http://blog.peachyy.com| |TE |客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息| TE: trailers,deflate;q=0.5| |Upgrade |向服务器指定某种传输协议以便服务器进行转换（如果支持）| Upgrade: HTTP/2.0, |SHTTP/1.3, IRC/6.9, RTA/x11| |User-Agent | User-Agent 的内容包含发出请求的用户信息 |User-Agent: Mozilla/5.0 (Linux; X11)| |Via | 通知中间网关或代理服务器地址，通信协议| Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)| |Warning |关于消息实体的警告信息 |Warn: 199 Miscellaneous warning| Responses Header 含义 例子 Accept-Ranges 表明服务器是否支持指定范围请求及哪种类型的分段请求 Accept-Ranges: bytes Age 从原始服务器到代理缓存形成的估算时间（以秒计，非负） Age: 12 Allow 对某网络资源的有效的请求行为，不允许则返回405 Allow: GET, HEAD Cache-Control 告诉所有的缓存机制是否可以缓存及哪种类型 Cache-Control: no-cache Content-Encoding web服务器支持的返回内容压缩编码类型。 Content-Encoding: gzip Content-Language 响应体的语言 Content-Language: en,zh Content-Length 响应体的长度 Content-Length: 348 Content-Location 请求资源可替代的备用的另一地址 Content-Location: /index.htm Content-MD5 返回资源的MD5校验值 Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ== Content-Range 在整个返回体中本部分的字节位置 Content-Range: bytes 21010-47021/47022 Content-Type 返回内容的MIME类型 Content-Type: text/html; charset=utf-8 Date 原始服务器消息发出的时间 Date: Tue, 15 Nov 2010 08:12:31 GMT ETag 请求变量的实体标签的当前值 ETag: “737060cd8c284d8af7ad3082f209582d” Expires 响应过期的日期和时间 Expires: Thu, 01 Dec 2010 16:00:00 GMT Last-Modified 请求资源的最后修改时间 Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT Location 用来重定向接收方到非请求URL的位置来完成请求或标识新的资源 Location: http://www.zcmhi.com/archives/94.html Pragma 包括实现特定的指令，它可应用到响应链上的任何接收方 Pragma: no-cache Proxy-Authenticate 它指出认证方案和可应用到代理的该URL上的参数 Proxy-Authenticate: Basic refresh 应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持） Refresh: 5; url= http://blog.peachyy.com Retry-After 如果实体暂时不可取，通知客户端在指定时间之后再次尝试 Retry-After: 120 Server web服务器软件名称 Server: Apache/1.3.27 (Unix) (Red-Hat/Linux) Set-Cookie 设置Http Cookie Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1 Trailer 指出头域在分块传输编码的尾部存在 Trailer: Max-Forwards Transfer-Encoding 文件传输编码 Transfer-Encoding:chunked Vary 告诉下游代理是使用缓存响应还是从原始服务器请求 Vary: * Via 告知代理客户端响应是通过哪里发送的 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 警告实体可能存在的问题 Warning: 199 Miscellaneous warning WWW-Authenticate 表明客户端请求实体应该使用的授权方案 WWW-Authenticate: Basic @see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html 网络。</div><div class="post-footer clearfix"> <a href="/2015/08/19/httpinfolist/" class="post-more waves-effect waves-button waves-light">阅读更多</a></div></article></li><li class="post-list-item"><article id="post-java8newcharacteristics" class="article article-type-post" itemprop="blogPost"><h3 class="post-title" itemprop="name"> <a class="post-title-link" href="/2015/08/10/java8newcharacteristics/">java8中的一些新特性</a></h3><div class="post-meat flex-row"><div class="flex-col"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java8/">java8</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/新特性/">新特性</a></li></ul></div> <time datetime="2015-08-09T16:00:00.000Z" itemprop="datePublished" class="post-tiem">2015-08-10</time></div><div class="post-content" id="post-content" itemprop="postContent"> 最近看了一下 java8 中的新增特性 新添加的东西个人认为并不多，主要是 lambda 表达式 其他的比较少。 因为之前看过 Groovy 它里面有一种语法叫 闭包/Closure 而java8中的lambda和Groovy中所谓的闭包非常相似，官方也称lambda表达式也可以叫闭包 难道是相互模仿? 不过 ruby 这些语言的写法确实非常优雅 未来的java语法也会像 ruby 一样么 这个是未知的。至少Groovy的出现 证明是可以这么做的。 函数的引用 这里所说的函数 包含普通函数 和构造函数 java8中使用 :: 关键字来传递方法或者构造函数引用 示例如下 这里引用了 Integer.valueOf() 方法 public class FunctionDemo &#123; public static void main (String[] args) &#123; Function&lt;String,Integer&gt; fordate=Integer::valueOf; Integer l=fordate.apply( "25" ); System.out.println(l); &#125; &#125; Lambda 表达式 其实会了Groovy中的闭包以后 java中Lambda表达式基本差不多。 语法 : ()-&gt;{} (int x, int y) -&gt; x + y; (x, y) -&gt; { return x + y; } //显式指明返回值 可见由3部分组成 参数列表，箭头（-&gt;），以及一个表达式或语句块 先给出一个demo 在后面会频繁的使用到Lambda表达式 一个foreach循环 只需要一行代码就搞定。是不是又节约了代码了呢 public class LambdaDemo &#123; public static void main (String[] args) &#123; List&lt;String&gt; list= new ArrayList&lt;&gt;(); list.add( "a1" ); list.add( "a2" ); list.add( "a3" ); list.add( "a4" ); list.add( "a5" ); list.add( "a6" ); list.add( "a7" ); list.forEach(o -&gt; &#123;System.out.println(o);&#125;); //... &#125; &#125; 在接口(interface)中定义默认方法实现 public interface foo &#123; public void sayHell (String hello) ; //默认方法 default double abs ( int a) &#123; return Math.abs(a); &#125; //impl public class fooimpl implements foo &#123; @Override public void sayHell (String hello) &#123; System.out.println( "say:" +hello); &#125; public static void main (String[] args) &#123; foo f= new fooimpl(); f.sayHell( "fff" ); System.out.println(f.abs( 20 )); &#125; &#125; &#125; 函数式接口 首先介绍一个注解 @FunctionalInterface 用来表示这个接口类是不一般的。这是一个函数式接口 如果你违反了函数式接口的规范 那么编译器就会报错,当然这个不是必须的、为了方便阅读代码尽量应该标识。 什么是函数式接口呢? 接口中可以额外定义多个抽象方法、需要注意的是这些抽象方法的修饰签名必须和Object的public一样 举个例子 示例一 是函数式接口 @FunctionalInterface public interface ccc &#123; void sum () ; //来自父类public的toString方法 @Override String toString () ; &#125; 示例二 不是函数式接口 因为clone不是public @FunctionalInterface public interface ccc &#123; void sum () ; //来自父类protected的clone方法 @Override Object clone () ; &#125; 列出java8之前已有的函数接口 java.lang.Runnable java.util.concurrent.Callable java.security.PrivilegedAction java.util.Comparator java.io.FileFilter java.nio.file.PathMatcher java.lang.reflect.InvocationHandler java.beans.PropertyChangeListener java.awt.event.ActionListener javax.swing.event.ChangeListener java8新定义的函数式接口 在rt.jar java.util.function包中 java.util.function.Predicate java.util.function.Consumer java.util.function.Function java.util.function.Supplier java.util.function.UnaryOperator java.util.function.BinaryOperator 那么接下来自定义一个简单的函数接口，你会发现与其他的普通java接口的区别莫过于实现具体的方式变了、变得更加简单 要是jdk1.8之前 会使用到匿名类或者写一个实现类 看到这种写法 以前简直就弱爆了。这就是函数式接口的魅力所在。 @FunctionalInterface //定义一个函数接口ccc public interface ccc &#123; int sum ( int x, int y) ; @Override String toString () ; //这是一个测试类 public class cccTest &#123; public static void main (String[] args) &#123; //一行代码告别匿名类 ccc target=( x, y)-&gt;&#123; int sum=x+y; return sum;&#125;; //调用sum方法 System.out.println(target.sum( 9 , 4 )); &#125; &#125; &#125; Predicate 接口 示例 当传入的参数为null或者长度=0 或者长度&gt;3 那么返回true 否则返回false 接口里面默认提供几个默认方法 default Predicate and(Predicate&lt;? super T&gt; other) 追加and条件 default Predicate negate() 从源码来看 应该是取反值得意思 如test()返回true 那么negate返回false 反之 default Predicate or(Predicate&lt;? super T&gt; other) 追加or条件 示例有用到 public class PredicateDemo &#123; public static void main (String[] args) &#123; Predicate&lt;String&gt; lengthgt3=(s)-&gt;&#123; return s!= null &amp;&amp;s.length()&gt; 3 ;&#125;; lengthgt3=lengthgt3.or((s)-&gt;&#123; return s== null || s.length()== 0 ;&#125;); boolean b= false ; b=lengthgt3.test( null ); System.out.println(b); &#125; &#125; Function 接口 示例 public class FunctionDemo &#123; public static void main (String[] args) &#123; Function&lt;String,Integer&gt; fordate=Integer::valueOf; Integer l=fordate.apply( "25" ); System.out.println(l); &#125; &#125; Supplier 接口 示例 实例化对象 需要注意的是 对象必须要拥有一个无参的构造函数 否则会编译出错。supplier紧紧只有一个get方法 public class SupplierDemo &#123; public static void main (String[] args) &#123; Supplier&lt;User&gt; personSupplier = User:: new ; User u=personSupplier.get(); System.out.println(u.getClass()); &#125; &#125; Consumer 接口 示例 操作单个对象处理 具有一个默认方法 default Consumer andThen(Consumer&lt;? super T&gt; after) public class ConsumerDemo &#123; public static void main (String[] args) &#123; User u1= new User( "xx1" , 20 ); User u2= new User( "xx2" , 21 ); Consumer&lt;User&gt; opt=(u)-&gt;&#123;System.err.println(u.getName()+ "年龄是" +u.getAge());&#125;; opt.accept(u2); &#125; &#125; 操作单个数据 感觉用处并不是很大。 Comparator 接口 示例 比较的时候用得比较多 JDK8中又新增一些方法。以下示例实现了使用compareTo 方法对user对象按照age字段排序 public class ComparatorDemo &#123; public static void main (String[] args) &#123; User u1= new User( "xx1" , 25 ); User u2= new User( "xx2" , 21 ); List&lt;User&gt; uList= new ArrayList&lt;&gt;(); uList.add(u1); uList.add(u2); uList.sort((t ,t1)-&gt;&#123; return t.getAge().compareTo(t1.getAge()); &#125;); for ( int i = 0 ; i &lt; uList.size(); i++) &#123; System.out.println(uList.get(i).getName()+ "~" +uList.get(i).getAge()); &#125; &#125; &#125; 还有一些JDK8自带的 函数式接口 不再一一列举 使用方式都差不多一样的。 Stream序列 Stream 接口拥有很多方法。都是很方便操作数据的。如 Filter 、Sort、count、min、max等等。</div><div class="post-footer clearfix"> <a href="/2015/08/10/java8newcharacteristics/" class="post-more waves-effect waves-button waves-light">阅读更多</a></div></article></li><li class="post-list-item"><article id="post-simplejsPreview1" class="article article-type-post" itemprop="blogPost"><h3 class="post-title" itemprop="name"> <a class="post-title-link" href="/2015/07/22/simplejsPreview1/">js常见面试题</a></h3><div class="post-meat flex-row"><div class="flex-col"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul></div> <time datetime="2015-07-21T16:00:00.000Z" itemprop="datePublished" class="post-tiem">2015-07-22</time></div><div class="post-content" id="post-content" itemprop="postContent"> 列出几道js面试中的题,无意中在什么站点看到的，便记录一下。看完这些题后 你还敢说js很简单么,简直是最优雅 博大精深的语言了。 1、函数声明优先于var var a; function a ( ) &#123; &#125; alert( typeof a); // ? 2、this scope arguments scope var length = 10 function fn ( ) &#123; alert( this .length) &#125; var obj = &#123; length : 5 , method : function ( fn ) &#123; fn() // ?   arguments [ 0 ]() // ?     &#125; &#125; obj.method(fn) 3、函数表达式具名（函数声明同时赋值给另一个变量）或函数声明立即执行时，名仅在该函数内可访问 (不考虑IE 6 7 8) ~ function ( ) &#123;     alert( typeof next) // ?     ~ function next ( ) &#123;         alert( typeof next) // ?     &#125;() &#125;() 4、隐式的全局变量 var a = 1 function func ( ) &#123;     a = b = 2 &#125; func() alert(a) alert(b) // ? 5、变量声明早于代码运行（Scoping and Hoisting） var uname = 'jack' function change ( ) &#123;     alert(uname) // ?      var uname = 'lily'     alert(uname) &#125; change() 还敢说自己JS很NB么 来源于网络、具体在哪记不得了 后来补上出处。由于自己也并非是专业的前端 所以也做错了好几题。</div><div class="post-footer clearfix"> <a href="/2015/07/22/simplejsPreview1/" class="post-more waves-effect waves-button waves-light">阅读更多</a></div></article></li><li class="post-list-item"><article id="post-lovewhat" class="article article-type-post" itemprop="blogPost"><h3 class="post-title" itemprop="name"> <a class="post-title-link" href="/2015/07/21/lovewhat/">爱是什么</a></h3><div class="post-meat flex-row"><div class="flex-col"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/爱是什么/">爱是什么</a></li></ul></div> <time datetime="2015-07-20T16:00:00.000Z" itemprop="datePublished" class="post-tiem">2015-07-21</time></div><div class="post-content" id="post-content" itemprop="postContent"> 多年后 偶尔会想起曾经是如此放松的快乐。 爱 是什么 爱 怎样才算爱 是爱吗 过了很久 已经完全忘记 如果没有爱 能活下去吗 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;写于不知道第几次回想曾经的快乐 &gt;</div><div class="post-footer clearfix"> <a href="/2015/07/21/lovewhat/" class="post-more waves-effect waves-button waves-light">阅读更多</a></div></article></li><li class="post-list-item"><article id="post-browerNotification" class="article article-type-post" itemprop="blogPost"><h3 class="post-title" itemprop="name"> <a class="post-title-link" href="/2015/07/21/browerNotification/">浏览器对Notification通知的支持</a></h3><div class="post-meat flex-row"><div class="flex-col"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul></div> <time datetime="2015-07-20T16:00:00.000Z" itemprop="datePublished" class="post-tiem">2015-07-21</time></div><div class="post-content" id="post-content" itemprop="postContent"> 记得在上一次的项目中需要实现一个BS的IM通信小功能、当新信息到达时 会在当前网站的右下角弹出一小弹框来提示用户有新的信息了。当时是在站内弹出一个类似WINDOW这样的窗口来实现的。其实这也可以满足用户的需求、当客户又提出来如果在浏览其他网站的时候、或者浏览器最小化的时候 我怎么知道是否有新消息呢? 当时认为这就是CS对于BS而言的优势所在。当然问题一直都没有得到改善 直到最近在W3C上看到 http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html http://www.w3.org/TR/notifications/ 这篇文章时候、很有自信的说 这种问题已经可以解决了。遗憾的是已经离开了那一家公司。 Notation 被 W3C 提出是浏览器通知的一个标准，最初的草案叫做 webkitNotifications 在网上说 Notation 是未来的标准化，目前还有很多浏览器厂商不支持这个标准。根据测试和网上所知 目前只有 Chrome 、 Opera 支持，相信很快其他浏览器也会被支持，因为真的很有用。比如像人人网、微信网页版 都使用了这种技术，给用户带来了极高的体验。 在chrome console所知 notification拥有一个构造函数 具备以下的一些属性和方法 Notification &#123;icon: "", tag: "", body: "I'm an enginneer!", lang: "", dir: "auto"…&#125; body: "I'm an enginneer!" dir: "auto" icon: "" lang: "" onclick: null onclose: null onerror: null onshow: null tag: "" title: "Hello Notification" __proto__: Notification close: function close() &#123; [native code] &#125; arguments: null caller: null length: 0 name: "close" __proto__: function Empty() &#123;&#125; &lt; function scope &gt; constructor: function Notification() &#123; [native code] &#125; arguments: null caller: null length: 1 name: "Notification" permission: "default" prototype: Notification requestPermission: function requestPermission() &#123; [native code] &#125; toString: function toString() &#123; [native code] &#125; __proto__: function EventTarget() &#123; [native code] &#125; &lt; function scope &gt; __proto__: EventTarget 构造函数一共有2个参数 一个是title 另一个则是配置项 如下 属性 含义 默认值 dir 未知 auto lang 应该是国际化用的 null body 通知内容 null tag 标记/ID null icon 图标 异常显示 null Permission查看权限值 Notification.permission "default" permission 是一个静态属性 这个属性比较特殊是不可以手动去修改值的，只能用户通过授权提示来控制，他的值一共有3个如下 default 拒绝 denied 用户不需要通知功能 granted 启动通知了 要使用通知 必须要得到用户的授权后才可以使用，使用 Notification.requestPermission() 向用户请求通知授权 会出现一个是否确认授权的确认框，已经启动通知了将被忽略。 new Notification( 'notifi' ,&#123; body : '这是一个优雅的提醒' , icon : 'http://blog.peachyy.com/public/images/logo.png' &#125;); 执行代码后 会在右下角弹出一个浏览器级别的通知框 demo地址： http://cqweclick.github.io/notification.html</div><div class="post-footer clearfix"> <a href="/2015/07/21/browerNotification/" class="post-more waves-effect waves-button waves-light">阅读更多</a></div></article></li><li class="post-list-item"><article id="post-mongoEVcreate" class="article article-type-post" itemprop="blogPost"><h3 class="post-title" itemprop="name"> <a class="post-title-link" href="/2015/07/15/mongoEVcreate/">mongo[一] @环境搭建</a></h3><div class="post-meat flex-row"><div class="flex-col"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MongoDB/">MongoDB</a></li></ul></div> <time datetime="2015-07-14T16:00:00.000Z" itemprop="datePublished" class="post-tiem">2015-07-15</time></div><div class="post-content" id="post-content" itemprop="postContent"> 之前研究过一个Nosql数据库 redis 性能真的很好。不用为数据结构的标准规范为烦恼，这也许就是K V结构的真正意义。 mongo也是一种Nosql数据库 但它是基于文档的方式。听起来感觉比redis更好操作 也是当前nosql 比较优的产品，当然redis也是非常优秀的，客户量也很大，所以在这里记录我对mongo的一些使用经历。 mongo几乎支持所有的操作系统，Window、Linux、Mac、Solaris 官方比较建议在linux中使用 具体原因不知。为了方便 这里是使用Window。 下载 在 https://www.mongodb.org/downloads 这里使用的版本是2.0.8 for window 附上链接-&gt; http://share.weiyun.com/0d378b0bee389ea583025d9728a5bea0 这是一个ZIP版本,把文件解压到 E:\Dev\ 并把目录名称改为 mongodb 使用命令行进入 E:\Dev\mongodb\bin 目录 也可以把这个加入到计算机的path 加入已经成功把 E:\Dev\mongodb\bin 加入计算机path E:\Dev\mongodb&gt;mongod --version db version v2.0.8-rc1-pre-, pdfile version 4.5 Wed Jul 15 17:24:12 git version: 1d3d3ba938b9ac0d627fd8039ad8aee79c6968c4 输入命令 mongod –version出现上面的回复。则说明环境安装成功了。 mongod具有很多命令 使用 mongod --help 可以查看到mongod具备的所有命令。下面是命令的详细说明摘自网络 基本配置 -------------------------------------------------------------------------------- --quiet # 安静输出 --port arg # 指定服务端口号，默认端口27017 --bind_ip arg # 绑定服务IP，若绑定127.0.0.1，则只能本机访问，不指定默认本地所有IP --logpath arg # 指定MongoDB日志文件，注意是指定文件不是目录 --logappend # 使用追加的方式写日志 --pidfilepath arg # PID File 的完整路径，如果没有设置，则没有PID文件 --keyFile arg # 集群的私钥的完整路径，只对于Replica Set 架构有效 --unixSocketPrefix arg # UNIX域套接字替代目录,(默认为 /tmp) --fork # 以守护进程的方式运行MongoDB，创建服务器进程 --auth # 启用验证 --cpu # 定期显示CPU的CPU利用率和iowait --dbpath arg # 指定数据库路径 --diaglog arg # diaglog选项 0=off 1=W 2=R 3=both 7=W+some reads --directoryperdb # 设置每个数据库将被保存在一个单独的目录 --journal # 启用日志选项，MongoDB的数据操作将会写入到journal文件夹的文件里 --journalOptions arg # 启用日志诊断选项 --ipv6 # 启用IPv6选项 --jsonp # 允许JSONP形式通过HTTP访问（有安全影响） --maxConns arg # 最大同时连接数 默认2000 --noauth # 不启用验证 --nohttpinterface # 关闭http接口，默认关闭27018端口访问 --noprealloc # 禁用数据文件预分配(往往影响性能) --noscripting # 禁用脚本引擎 --notablescan # 不允许表扫描 --nounixsocket # 禁用Unix套接字监听 --nssize arg (=16) # 设置信数据库.ns文件大小(MB) --objcheck # 在收到客户数据,检查的有效性， --profile arg # 档案参数 0=off 1=slow, 2=all --quota # 限制每个数据库的文件数，设置默认为8 --quotaFiles arg # number of files allower per db, requires --quota --rest # 开启简单的rest API --repair # 修复所有数据库run repair on all dbs --repairpath arg # 修复库生成的文件的目录,默认为目录名称dbpath --slowms arg (=100) # value of slow for profile and console log --smallfiles # 使用较小的默认文件 --syncdelay arg (=60) # 数据写入磁盘的时间秒数(0=never,不推荐) --sysinfo # 打印一些诊断系统信息 --upgrade # 如果需要升级数据库 * Replicaton 参数 -------------------------------------------------------------------------------- --fastsync # 从一个dbpath里启用从库复制服务，该dbpath的数据库是主库的快照，可用于快速启用同步 --autoresync # 如果从库与主库同步数据差得多，自动重新同步， --oplogSize arg # 设置oplog的大小(MB) * 主/从参数 -------------------------------------------------------------------------------- --master # 主库模式 --slave # 从库模式 --source arg # 从库 端口号 --only arg # 指定单一的数据库复制 --slavedelay arg # 设置从库同步主库的延迟时间 * Replica set(副本集)选项： -------------------------------------------------------------------------------- --replSet arg # 设置副本集名称 * Sharding(分片)选项 -------------------------------------------------------------------------------- --configsvr # 声明这是一个集群的config服务,默认端口27019，默认目录/data/configdb --shardsvr # 声明这是一个集群的分片,默认端口27018 --noMoveParanoia # 关闭偏执为moveChunk数据保存 要启动数据库 必须要为mongo指定一个数据库数据文件的存放的目录 需要使用 mongod --dbpath 命令来完成，在d:\dev\ 创建一个mongodbDATA文件夹 用来存储mongo的数据库文件 mongod --dbpath E:\Dev\mongodbDATA Wed Jul 15 17:35:26 [initandlisten] MongoDB starting : pid=9368 port=27017 dbpat h=E:\Dev\mongodbDATA 64-bit host=pc-PC Wed Jul 15 17:35:26 [initandlisten] db version v2.0.8-rc1-pre-, pdfile version 4 .5 Wed Jul 15 17:35:26 [initandlisten] git version: 1d3d3ba938b9ac0d627fd8039ad8aee 79c6968c4 Wed Jul 15 17:35:26 [initandlisten] build info: windows sys.getwindowsversion(ma jor=6, minor=1, build=7601, platform=2, service_pack='Service Pack 1') BOOST_LIB _VERSION=1_42 Wed Jul 15 17:35:26 [initandlisten] options: &#123; dbpath: "E:\Dev\mongodbDATA" &#125; Wed Jul 15 17:35:26 [initandlisten] journal dir=E:/Dev/mongodbDATA/journal Wed Jul 15 17:35:26 [initandlisten] recover : no journal files present, no recov ery needed Wed Jul 15 17:35:26 [initandlisten] waiting for connections on port 27017 Wed Jul 15 17:35:26 [websvr] admin web console waiting for connections on port 2 8017 到这里 mongo数据库算是启动OK了。 注意控制台最后两句Log Wed Jul 15 17:35:26 [initandlisten] waiting for connections on port 27017 Wed Jul 15 17:35:26 [websvr] admin web console waiting for connections on port 28017 数据库连接端口27017 数据库web控制台端口28017 既然是web应该可以使用浏览器访问试试。 http://localhost:28017/ 能访问成功能证明我们的数据库是真的启动成功了。 下面将使用客户端连接数据库试试 新开一个CMD命令行窗口 输入 mongo 命令 mongodb会自动连接到test数据库 如下所示 C:\Users\pc&gt;mongo MongoDB shell version: 2.0.8-rc1-pre- connecting to: test &gt; 说明连接数据库服务器成功了。 环境搭建非常简单。需要熟悉一个mongod的一些常用命令 为后续更深入的了解做铺垫。</div><div class="post-footer clearfix"> <a href="/2015/07/15/mongoEVcreate/" class="post-more waves-effect waves-button waves-light">阅读更多</a></div></article></li><li class="post-list-item"><article id="post-ReadisStudy7" class="article article-type-post" itemprop="blogPost"><h3 class="post-title" itemprop="name"> <a class="post-title-link" href="/2015/07/14/ReadisStudy7/">redis客户端 for java</a></h3><div class="post-meat flex-row"><div class="flex-col"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/">Redis</a></li></ul></div> <time datetime="2015-07-13T16:00:00.000Z" itemprop="datePublished" class="post-tiem">2015-07-14</time></div><div class="post-content" id="post-content" itemprop="postContent"> 当然在数据中直接操作 redis 命令是没有什么价值和意义的，之所以使用她 是让她为我们的应用提供数据存储服务，让客户感受到价值所在。 redis她拥有很多种客户端连接工具 她几乎支持所有语言，比如 c , c# , c++ , Clojure , Common Lisp , d , Java , ruby , php ….等等。 下面主要描述一下 java 语言对redis的支持。单单只是 java 语言的客户端就有好多种，比如 Jedis , lettuce , aredis , JRedis 等。都是由众多的开发者贡献出来的，将来肯定会越来越多、就当前来说，Jedis lettuce都是比较常用的，其他这么多得客户端连接工具，使用方法都差不多的。所以一般只要能使用一个其他的也是OK的。最喜欢用的还是 Jedis 所以以下的示例代码中也将会是使用 Jedis 连接数据库。 maven依赖 &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; 帮助类 DButi.java public class DButil &#123; //在 org.apache.commons.pool.impl.GenericObjectPool 可以看到一些参数的默认值 //主机IP private static final String HOST= "localhost" ; //端口 private static final Integer PORT= 6379 ; //认证密码 private static final String AUTH_PAS= "xstao" ; //最大活动数目 private static final Integer MAX_ACTIVE = 20 ; //指定pool池 最多有多少个状态为idle private static final Integer MAX_IDLE= 100 ; //最长等待时间 毫秒 private static final Integer MAX_WAIT= 5000 ; //超时 private static final Integer TIME_OUT= 5000 ; private static JedisPool poolInstance= null ; /*** * 获取jedis 池实例对象 * @date 2015年7月14日 上午11:38:15 * @author xs Tao * @return */ public static JedisPool getJedisPoolInstance () &#123; if (poolInstance== null )&#123; //连接redis数据库 的参数对象 JedisPoolConfig config= new JedisPoolConfig(); config.setMaxActive(MAX_ACTIVE); config.setMaxWait(MAX_WAIT); config.setMaxIdle(MAX_IDLE); //创建池 拥有多个构造函数 //如果是默认的端口号 也可以使用默认端口号的构造函数。就连主机也是可以默认的。 poolInstance= new JedisPool(config, HOST, PORT, TIME_OUT, AUTH_PAS); &#125; return poolInstance; &#125; public static Jedis getJedis () &#123; if (poolInstance== null )&#123; DButil.getJedisPoolInstance(); &#125; //从池连接中 获取一个jedis资源 Jedis jedis= poolInstance.getResource(); return jedis; &#125; /** * 销毁jedis连接 * @date 2015年7月14日 上午11:43:03 * @author xs Tao * @param jedis */ public static void destory (Jedis jedis) &#123; if (poolInstance!= null &amp;&amp; jedis!= null )&#123; poolInstance.returnResource(jedis); &#125; &#125; &#125; 由于redis是使用K V来存储 所以会存在大量的 难以维护的K 一般会定义个生产KEY的类。用来定义系统K的生成规则 KeyUtils.java public class KeyUtils &#123; static String UID= "demo:uid" ; static String UID_AUTO_NUM= "demo-uid-index" ; public static String getUID (String uid) &#123; return UID.concat(uid); &#125; &#125; 用户实体类 public class User implements java . io . Serializable &#123; /** * */ private static final long serialVersionUID = 1L ; private String id; private String name; private String password; private String age; private String sex; /** * @return the id */ public String getId () &#123; return id; &#125; /** * @param id the id to set */ public void setId (String id) &#123; this .id = id; &#125; /** * @return the name */ public String getName () &#123; return name; &#125; /** * @param name the name to set */ public void setName (String name) &#123; this .name = name; &#125; /** * @return the password */ public String getPassword () &#123; return password; &#125; /** * @param password the password to set */ public void setPassword (String password) &#123; this .password = password; &#125; /** * @return the age */ public String getAge () &#123; return age; &#125; /** * @param age the age to set */ public void setAge (String age) &#123; this .age = age; &#125; /** * @return the sex */ public String getSex () &#123; return sex; &#125; /** * @param sex the sex to set */ public void setSex (String sex) &#123; this .sex = sex; &#125; public Map&lt;String, String&gt; toMap () &#123; Map&lt;String, String&gt; map= new HashMap&lt;String, String&gt;(); map.put( "id" , this .id); map.put( "name" , this .name); map.put( "password" , this .password); map.put( "age" , this .age); map.put( "sex" , this .sex); return map; &#125; &#125; 一个测试类 test.java public class test &#123; public static void main (String[] args) &#123; Jedis jedis=DButil.getJedis(); String uid=String.valueOf(jedis.incr(KeyUtils.UID_AUTO_NUM)); User user= new User(); user.setAge( "23" ); user.setId(uid); user.setName( "happy" ); user.setPassword( "5757124" ); user.setSex( "男" ); jedis.hmset(KeyUtils.getUID(uid),user.toMap()); System.out.println(jedis.hget(KeyUtils.getUID(uid), "name" )); &#125; &#125; 还有一个优秀封装redis客户端的项目 叫做 http://projects.spring.io/spring-data-redis/ 官方称在将来会兼容所有的redis java语言客户端 示例代码 https://github.com/peachyy/weclickSrc/tree/master/rs-parent/rs-redis</div><div class="post-footer clearfix"> <a href="/2015/07/14/ReadisStudy7/" class="post-more waves-effect waves-button waves-light">阅读更多</a></div></article></li><li class="post-list-item"><article id="post-fillingLookLook" class="article article-type-post" itemprop="blogPost"><h3 class="post-title" itemprop="name"> <a class="post-title-link" href="/2015/06/19/fillingLookLook/">当你想放弃的时候就看看这个吧</a></h3><div class="post-meat flex-row"><div class="flex-col"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/坚持/">坚持</a></li></ul></div> <time datetime="2015-06-18T16:00:00.000Z" itemprop="datePublished" class="post-tiem">2015-06-19</time></div><div class="post-content" id="post-content" itemprop="postContent"> 迷路、想放弃、对生活绝望时看看这个.肯定会好一点的</div><div class="post-footer clearfix"> <a href="/2015/06/19/fillingLookLook/" class="post-more waves-effect waves-button waves-light">阅读更多</a></div></article></li><li class="post-list-item"><article id="post-ReadisStudy4-list" class="article article-type-post" itemprop="blogPost"><h3 class="post-title" itemprop="name"> <a class="post-title-link" href="/2015/06/11/ReadisStudy4-list/">Redis[四] @List 列表</a></h3><div class="post-meat flex-row"><div class="flex-col"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/">Redis</a></li></ul></div> <time datetime="2015-06-10T16:00:00.000Z" itemprop="datePublished" class="post-tiem">2015-06-11</time></div><div class="post-content" id="post-content" itemprop="postContent"> http://redisdoc.com/s Redis 列表是简单的字符串列表，排序插入顺序。您可以在头部或列表的尾部Redis的列表添加元素。 1、使用 lpush 命令 添加一个list1 拥有元素 1 2 3 并返回list1的长度 注意 取出顺序是 先进后出 2、并使用 lrange 命令获取list中的指定索引元素 0 -1表示从0开始 到len结束 格式：LRANGE key start stop 3、 llen 命令取得list1长度 redis 127.0.0.1:6379&gt; lpush list1 1 2 3 (integer) 3 redis 127.0.0.1:6379&gt; lrange list1 0 -1 1) "3" 2) "2" 3) "1" redis 127.0.0.1:6379&gt; llen list1 (integer) 3 redis 127.0.0.1:6379&gt; 这种很笨的先进后出做法确实不够好，那么我想最后添加的最先出来怎么办呢？当然了 效率如此高的redis肯定是ok的。 使用 lpushx 命令 可以添加到当前列表的最前面 输出结果可以看到我们最后添加的4被排到了最前面去了。 redis 127.0.0.1:6379&gt; lpushx list1 4 (integer) 4 redis 127.0.0.1:6379&gt; lrange list1 0 -1 1) "4" 2) "3" 3) "2" 4) "1" 根据指定键 指定索引获取列表中的数据 注意 索引是从0开始的。 redis 127.0.0.1:6379&gt; lindex list1 0 "4" 使用 linsert key before|after oldval newval 命令可以实现向指定key 指定一个元素值得前面 | 后面 插入一个值 如下实现的是 向list1中元素4之前插入a 并遍历元素 然后 又向元素4之后插入b 并遍历显示元素 redis 127.0.0.1:6379&gt; linsert list1 before 4 a (integer) 5 redis 127.0.0.1:6379&gt; lrange list1 0 -1 1) "a" 2) "4" 3) "3" 4) "2" 5) "1" redis 127.0.0.1:6379&gt; linsert list1 after 4 b (integer) 6 redis 127.0.0.1:6379&gt; lrange list1 0 -1 1) "a" 2) "4" 3) "b" 4) "3" 5) "2" 6) "1" LPOP key 删除列表中的第一个元素 并返回。 redis 127.0.0.1:6379&gt; lpop list1 "a" LREM key count value 从列表中删除元素 count表示删除的个数 value表示删除的需要删除的元素值 如下 先添加b list1列表中就具有3个b 那么我们就执行 lrem list1 2 b 删除2个b。 redis 127.0.0.1:6379&gt; linsert list1 after 3 b (integer) 6 redis 127.0.0.1:6379&gt; lrange list1 0 -1 1) "4" 2) "b" 3) "3" 4) "b" 5) "2" 6) "1" redis 127.0.0.1:6379&gt; linsert list1 after 2 b (integer) 7 redis 127.0.0.1:6379&gt; lrange list1 0 -1 1) "4" 2) "b" 3) "3" 4) "b" 5) "2" 6) "b" 7) "1" redis 127.0.0.1:6379&gt; lrem list1 2 b (integer) 2 redis 127.0.0.1:6379&gt; lrange list1 0 -1 1) "4" 2) "3" 3) "2" 4) "b" 5) "1" LSET key index value 更新指定索引的值 如下是 为list1中索引为3的重新赋值为b2 redis 127.0.0.1:6379&gt; lrange list1 0 -1 1) "4" 2) "3" 3) "2" 4) "b" 5) "1" redis 127.0.0.1:6379&gt; lset list1 3 b2 OK redis 127.0.0.1:6379&gt; lrange list1 0 -1 1) "4" 2) "3" 3) "2" 4) "b2" 5) "1" ltrim命令可以实现为裁剪指定索引区间的数据 如下是裁剪list1 中1下标——2下标中的数据 redis 127.0.0.1:6379&gt; ltrim list1 1 2 OK redis 127.0.0.1:6379&gt; lrange list1 0 -1 1) "3" 2) "2" rpush为列表添加元素 并实现 先进先出 的原则 与lpush相反 如下先添加1 2 3 4 返回的顺序也是 1 2 3 4 redis 127.0.0.1:6379&gt; rpush list2 1 2 3 4 (integer) 4 redis 127.0.0.1:6379&gt; lrange list2 0 -1 1) "1" 2) "2" 3) "3" 4) "4" RPOP key取出列表中最后一个元素 如下可知 list2中最后一个元素是4 redis 127.0.0.1:6379&gt; rpop list2 "4" RPOPLPUSH source destination 删除最后一个元素的列表，将其附加到另一个列表并返回它 如下list3并没有声明。而是把list2的最后一个元素保存到了list3列表中 redis 127.0.0.1:6379&gt; rpoplpush list2 list3 "3" redis 127.0.0.1:6379&gt; lrange list3 0 -1 1) "3"</div><div class="post-footer clearfix"> <a href="/2015/06/11/ReadisStudy4-list/" class="post-more waves-effect waves-button waves-light">阅读更多</a></div></article></li></ul><nav id="page-nav"><div class="inner"> <a class="extend prev" rel="prev" href="/page/3/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/">下一页</a></div></nav></div></main><div class="mask" id="mask"></div><a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a><script>var BLOG_SHARE={title:"笑松小站",pic:"/assets/images/logo.png",summary:document.getElementsByName("summary")[0].content,url:"http://blog.seoui.com/page/4/index.html"}</script><div class="global-share" id="global-share"><div class="tit">分享到：</div><ul class="reset share-icons"><li><a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina"><i class="icon icon-weibo"></i></a></li><li><a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin"><i class="icon icon-weixin"></i></a></li><li><a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq"><i class="icon icon-qq"></i></a></li><li><a class="facebook share-sns" href="javascript:;" data-title=" facebook" data-service="fb"><i class="icon icon-facebook"></i></a></li><li><a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter"><i class="icon icon-twitter"></i></a></li><li> <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">豆</a></li></ul></div><script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script><script src="/assets/scripts/main.js"></script><div class="search-panel" id="search-panel"><ul class="search-result" id="search-result"></ul></div><script type="text/template" id="search-tpl">
<li class="item">
    <a href="/{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</script><script src="/assets/scripts/search.js"></script><script src="//cdn.bootcss.com/jquery/1.12.3/jquery.min.js"></script><script src="/assets/fancybox/jquery.fancybox.js"></script><script type="text/javascript">var imgArr=$("#post-content img");if(null!=imgArr&&imgArr.length>0){for(var i=0,len=imgArr.length;i<len;i++){var src=imgArr.eq(i).attr("src"),title=imgArr.eq(i).attr("alt");imgArr.eq(i).replaceWith("<a href='"+src+"' title='"+title+"' rel='fancy-group' class='fancy-ctn fancybox'><img src='"+src+"' title='"+title+"'></a>")}$("#post-content .fancy-ctn").fancybox()}var cnzz_protocol="https:"==document.location.protocol?" https://":" http://";document.write(unescape("%3Cspan id='cnzz_stat_icon_1256496591'%3E%3C/span%3E%3Cscript src='"+cnzz_protocol+"s11.cnzz.com/stat.php%3Fid%3D1256496591%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E")),function(){var t=document.createElement("script"),r=window.location.protocol.split(":")[0];"https"===r?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var c=document.getElementsByTagName("script")[0];c.parentNode.insertBefore(t,c)}()</script></body></html>